<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Dino Survival - Phase 8</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%; overflow: hidden; background: #0a0a12;
      touch-action: none; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
    }
    #game-container {
      position: relative; width: 100%; height: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    #game-canvas {
      image-rendering: pixelated; image-rendering: crisp-edges;
      background: #1a2a1a; max-width: 100%; max-height: 70vh;
      border: 4px solid #2a3a2a; box-shadow: 0 0 40px rgba(0, 50, 0, 0.5);
    }
    #controls {
      position: fixed; bottom: 0; left: 0; right: 0; height: 30vh; min-height: 150px;
      display: flex; justify-content: space-between; align-items: center; padding: 20px 30px;
      background: linear-gradient(to top, rgba(10,10,18,0.95), rgba(10,10,18,0.7), transparent);
    }
    #dpad { position: relative; width: 130px; height: 130px; }
    .dpad-btn {
      position: absolute; width: 46px; height: 46px;
      background: linear-gradient(145deg, rgba(60,80,60,0.8), rgba(30,50,30,0.9));
      border: 2px solid rgba(100,140,100,0.5); border-radius: 8px;
      display: flex; align-items: center; justify-content: center;
      color: rgba(150,200,150,0.8); font-size: 16px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
    }
    .dpad-btn:active, .dpad-btn.pressed {
      background: linear-gradient(145deg, rgba(80,120,80,0.9), rgba(50,80,50,0.95));
      transform: scale(0.95);
    }
    #dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
    #dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
    #dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
    #dpad-right { right: 0; top: 50%; transform: translateY(-50%); }
    #action-buttons { display: flex; flex-direction: column; align-items: flex-end; gap: 8px; }
    #action-row-top { display: flex; gap: 10px; }
    #action-row-bottom { display: flex; gap: 12px; align-items: flex-end; }
    .action-btn {
      width: 65px; height: 65px; border-radius: 50%; border: 3px solid;
      display: flex; align-items: center; justify-content: center;
      color: white; font-family: 'Press Start 2P', monospace; font-size: 8px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 2px 0 rgba(255,255,255,0.2);
    }
    .action-btn.small {
      width: 52px; height: 52px; font-size: 7px;
    }
    .action-btn:active, .action-btn.pressed { transform: scale(0.92); }
    #btn-jump { background: linear-gradient(145deg, #4a8f4a, #2d6a2d); border-color: #6ab86a; margin-bottom: 25px; }
    #btn-attack { background: linear-gradient(145deg, #a84a4a, #7a2d2d); border-color: #c86a6a; }
    #btn-shoot { background: linear-gradient(145deg, #4a6a8f, #2d4a6a); border-color: #6a8ab8; }
    #btn-eat { background: linear-gradient(145deg, #8f6a4a, #6a4a2d); border-color: #b88a6a; }
    #btn-craft { background: linear-gradient(145deg, #6a4a8f, #4a2d6a); border-color: #8a6ab8; }
    #keyboard-hint {
      position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
      color: rgba(150,200,150,0.4); font-family: 'Press Start 2P', monospace; font-size: 8px;
    }
    @media (pointer: coarse) { #keyboard-hint { display: none; } }
    @media (pointer: fine) { #controls { opacity: 0.4; } #controls:hover { opacity: 1; } }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="keyboard-hint">ARROWS: Move | SPACE: Jump | Z: Attack | X: Shoot | C: Craft</div>
  </div>
  <div id="controls">
    <div id="dpad">
      <button class="dpad-btn" id="dpad-up">UP</button>
      <button class="dpad-btn" id="dpad-down">DN</button>
      <button class="dpad-btn" id="dpad-left">LT</button>
      <button class="dpad-btn" id="dpad-right">RT</button>
    </div>
    <div id="action-buttons">
      <div id="action-row-top">
        <button class="action-btn small" id="btn-eat">EAT</button>
        <button class="action-btn small" id="btn-craft">CRAFT</button>
      </div>
      <div id="action-row-bottom">
        <button class="action-btn" id="btn-shoot">GUN</button>
        <button class="action-btn" id="btn-attack">ATK</button>
        <button class="action-btn" id="btn-jump">JUMP</button>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      CANVAS_WIDTH: 480,
      CANVAS_HEIGHT: 270,
      LEVEL_WIDTH: 5000,
      GROUND_HEIGHT: 50,
      GROUND_STONE_HEIGHT: 16,

      PLAYER_SCALE: 1.4,
      ENEMY_SCALE: 0.95,
      
      PLAYER_SPEED: 180,
      PLAYER_SPEED_SLOW: 100,
      PLAYER_ACCELERATION: 1800,
      PLAYER_FRICTION: 1400,
      JUMP_FORCE: 340,
      GRAVITY: 980,
      MAX_FALL_SPEED: 550,
      CAMERA_LERP: 0.08,

      PLAYER_MAX_HEALTH: 100,
      PLAYER_DAMAGE: 25,
      HP_REGEN_RATE: 5,
      
      ENEMY_BASE_HEALTH: 60,
      ENEMY_BASE_DAMAGE: 15,
      ENEMY_BASE_SPEED: 80,
      ENEMY_BASE_CHASE_SPEED: 130,
      ENEMY_SIGHT_RANGE: 200,
      ENEMY_ATTACK_RANGE: 50,
      ENEMY_ATTACK_COOLDOWN: 0.8,
      ENEMY_RETREAT_DISTANCE: 80,

      MAX_HUNGER: 100,
      MAX_THIRST: 100,
      HUNGER_DRAIN: 1.5,
      THIRST_DRAIN: 2.0,
      STARVATION_DAMAGE: 3,
      DEHYDRATION_DAMAGE: 4,

      MEAT_RESTORE: 35,
      BERRY_RESTORE: 15,
      PUDDLE_RESTORE: 25,
      POND_RESTORE_RATE: 40,

      SPAWN_DISTANCE: 400,
      MAX_ENEMIES: 10,

      BULLET_SPEED: 350,
      RAPID_DAMAGE: 12,
      RAPID_FIRE_RATE: 0.12,
      ACID_DAMAGE: 25,
      ACID_FIRE_RATE: 0.5,
      BONE_CLUB_DAMAGE: 50,
      BONE_CLUB_RATE: 0.7,

      DEATH_ANIMATION_TIME: 1.5,
      ENEMY_DEATH_TIME: 1.0,

      DIFFICULTY_SCALE_START: 1000,
      DIFFICULTY_SCALE_RATE: 0.0002,

      // Day/Night cycle
      DAY_NIGHT_CYCLE_LENGTH: 120, // seconds for full day/night cycle
      
      // Resources & Crafting - NEW in Phase 9
      WOOD_PER_TREE: 3,
      STONE_PER_ROCK: 2,
      BONES_PER_ENEMY: 2,
      METAL_SPAWN_CHANCE: 0.15,
      
      RECIPES: {
        boneclub: { bones: 5, wood: 2 },
        rapidfire: { metal: 10, wood: 5 },
        acidgun: { bones: 8, stone: 3 },
        healthpotion: { berries: 3 },
        armor: { stone: 10, metal: 5 }
      }
    };

    // ============================================
    // DAY/NIGHT CYCLE
    // ============================================
    const DayNight = {
      time: 0, // 0 to 1 (0=midnight, 0.25=dawn, 0.5=noon, 0.75=dusk)
      
      update(dt) {
        this.time += dt / CONFIG.DAY_NIGHT_CYCLE_LENGTH;
        this.time = this.time % 1;
      },
      
      getSkyColors() {
        const t = this.time;
        
        // Night: 0-0.2 and 0.8-1
        // Dawn: 0.2-0.3
        // Day: 0.3-0.7
        // Dusk: 0.7-0.8
        
        if (t < 0.2) {
          // Night -> Dawn transition
          const phase = t / 0.2;
          return {
            top: this.lerpColor('#1a1a3a', '#4a5a8a', phase),
            mid: this.lerpColor('#2a2a4a', '#6a7aaa', phase),
            bottom: this.lerpColor('#3a3a5a', '#8a9aca', phase),
            horizon: this.lerpColor('#4a4a6a', '#aabae8', phase)
          };
        } else if (t < 0.3) {
          // Dawn -> Day transition
          const phase = (t - 0.2) / 0.1;
          return {
            top: this.lerpColor('#4a5a8a', '#5a9fd4', phase),
            mid: this.lerpColor('#6a7aaa', '#8ec5e8', phase),
            bottom: this.lerpColor('#8a9aca', '#b8ddf0', phase),
            horizon: this.lerpColor('#aabae8', '#d4eef8', phase)
          };
        } else if (t < 0.7) {
          // Day (full brightness)
          return {
            top: '#5a9fd4',
            mid: '#8ec5e8',
            bottom: '#b8ddf0',
            horizon: '#d4eef8'
          };
        } else if (t < 0.8) {
          // Dusk -> Night transition
          const phase = (t - 0.7) / 0.1;
          return {
            top: this.lerpColor('#5a9fd4', '#4a3a6a', phase),
            mid: this.lerpColor('#8ec5e8', '#6a5a8a', phase),
            bottom: this.lerpColor('#b8ddf0', '#8a6aaa', phase),
            horizon: this.lerpColor('#d4eef8', '#aa8aca', phase)
          };
        } else {
          // Night
          const phase = (t - 0.8) / 0.2;
          return {
            top: this.lerpColor('#4a3a6a', '#1a1a3a', phase),
            mid: this.lerpColor('#6a5a8a', '#2a2a4a', phase),
            bottom: this.lerpColor('#8a6aaa', '#3a3a5a', phase),
            horizon: this.lerpColor('#aa8aca', '#4a4a6a', phase)
          };
        }
      },
      
      lerpColor(color1, color2, t) {
        const r1 = parseInt(color1.slice(1, 3), 16);
        const g1 = parseInt(color1.slice(3, 5), 16);
        const b1 = parseInt(color1.slice(5, 7), 16);
        const r2 = parseInt(color2.slice(1, 3), 16);
        const g2 = parseInt(color2.slice(3, 5), 16);
        const b2 = parseInt(color2.slice(5, 7), 16);
        
        const r = Math.round(r1 + (r2 - r1) * t);
        const g = Math.round(g1 + (g2 - g1) * t);
        const b = Math.round(b1 + (b2 - b1) * t);
        
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
      },
      
      getBrightness() {
        const t = this.time;
        // Night: 0.4, Day: 1.0
        if (t < 0.2) return 0.4 + (t / 0.2) * 0.3; // 0.4 -> 0.7
        if (t < 0.3) return 0.7 + ((t - 0.2) / 0.1) * 0.3; // 0.7 -> 1.0
        if (t < 0.7) return 1.0; // Full day
        if (t < 0.8) return 1.0 - ((t - 0.7) / 0.1) * 0.3; // 1.0 -> 0.7
        return 0.7 - ((t - 0.8) / 0.2) * 0.3; // 0.7 -> 0.4
      },
      
      isNight() {
        return this.time < 0.2 || this.time > 0.8;
      },
      
      drawStars(ctx, camera, width, height) {
        if (!this.isNight()) return;
        
        const brightness = this.time < 0.2 ? (0.2 - this.time) / 0.2 : (this.time - 0.8) / 0.2;
        ctx.globalAlpha = brightness * 0.9;
        
        // Fixed star positions based on camera
        const starCount = 80;
        for (let i = 0; i < starCount; i++) {
          const x = ((i * 137.5) % width); // Pseudo-random but consistent
          const y = ((i * 73.2) % (height * 0.6));
          const size = 1 + (i % 3);
          const twinkle = Math.sin(Date.now() / 500 + i) * 0.3 + 0.7;
          
          ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
          ctx.fillRect(x, y, size, size);
        }
        
        ctx.globalAlpha = 1;
      },
      
      drawMoon(ctx, width, height) {
        if (!this.isNight()) return;
        
        const brightness = this.time < 0.2 ? (0.2 - this.time) / 0.2 : (this.time - 0.8) / 0.2;
        ctx.globalAlpha = brightness;
        
        const moonX = width * 0.8;
        const moonY = height * 0.15;
        const moonSize = 25;
        
        // Moon
        ctx.fillStyle = '#f8f8e0';
        ctx.beginPath();
        ctx.arc(moonX, moonY, moonSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Moon craters
        ctx.fillStyle = '#d8d8c0';
        ctx.beginPath();
        ctx.arc(moonX - 8, moonY - 5, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(moonX + 6, moonY + 3, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(moonX - 3, moonY + 8, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1;
      }
    };

    // ============================================
    // BIRDS SYSTEM  
    // ============================================
    const Birds = {
      birds: [],
      
      init() {
        const colors = ['#d44a4a', '#4a8ad4', '#d4aa4a', '#6ad44a', '#aa4ad4'];
        for (let i = 0; i < 12; i++) {
          this.birds.push({
            x: Math.random() * CONFIG.LEVEL_WIDTH,
            y: 20 + Math.random() * 60,
            speed: 30 + Math.random() * 40,
            flapPhase: Math.random() * Math.PI * 2,
            color: colors[Math.floor(Math.random() * colors.length)],
            size: 3 + Math.random() * 2
          });
        }
      },
      
      update(dt) {
        for (const bird of this.birds) {
          bird.x += bird.speed * dt;
          bird.flapPhase += dt * 8;
          if (bird.x > CONFIG.LEVEL_WIDTH + 100) {
            bird.x = -100;
            bird.y = 20 + Math.random() * 60;
          }
        }
      },
      
      draw(ctx, camera) {
        for (const bird of this.birds) {
          const sx = bird.x - camera.x * 0.15;
          if (sx < -20 || sx > CONFIG.CANVAS_WIDTH + 20) continue;
          
          const wingFlap = Math.sin(bird.flapPhase) * 3;
          ctx.fillStyle = bird.color;
          ctx.beginPath();
          ctx.moveTo(sx, bird.y);
          ctx.lineTo(sx - bird.size, bird.y - bird.size + wingFlap);
          ctx.lineTo(sx + bird.size, bird.y - bird.size + wingFlap);
          ctx.closePath();
          ctx.fill();
        }
      }
    };

    // ============================================
    // INVENTORY SYSTEM - NEW in Phase 9
    // ============================================
    const Inventory = {
      items: {
        berries: 0,
        meat: 0,
        wood: 0,
        stone: 0,
        bones: 0,
        metal: 0
      },
      collectibles: {
        eggs: 0,
        fossils: 0,
        crystals: 0
      },
      
      add(item, amount = 1) {
        if (this.items.hasOwnProperty(item)) {
          this.items[item] += amount;
          return true;
        }
        if (this.collectibles.hasOwnProperty(item)) {
          this.collectibles[item] += amount;
          return true;
        }
        return false;
      },
      
      has(item, amount = 1) {
        return (this.items[item] || 0) >= amount;
      },
      
      remove(item, amount = 1) {
        if (this.items.hasOwnProperty(item) && this.items[item] >= amount) {
          this.items[item] -= amount;
          return true;
        }
        return false;
      },
      
      reset() {
        for (let key in this.items) this.items[key] = 0;
        for (let key in this.collectibles) this.collectibles[key] = 0;
      }
    };

    // ============================================
    // CRAFTING SYSTEM - NEW in Phase 9
    // ============================================
    const CraftingUI = {
      isOpen: false,
      selectedRecipe: 0,
      recipeCount: 5,

      toggle() {
        this.isOpen = !this.isOpen;
        if (this.isOpen) {
          this.selectedRecipe = 0; // Reset selection when opening
        }
      },

      moveSelectionUp() {
        this.selectedRecipe = (this.selectedRecipe - 1 + this.recipeCount) % this.recipeCount;
      },

      moveSelectionDown() {
        this.selectedRecipe = (this.selectedRecipe + 1) % this.recipeCount;
      },
      
      canCraft(recipeName) {
        const recipe = CONFIG.RECIPES[recipeName];
        if (!recipe) return false;
        
        for (let item in recipe) {
          if (!Inventory.has(item, recipe[item])) return false;
        }
        return true;
      },
      
      craft(recipeName, player) {
        if (!this.canCraft(recipeName)) return false;
        
        const recipe = CONFIG.RECIPES[recipeName];
        for (let item in recipe) {
          Inventory.remove(item, recipe[item]);
        }
        
        // Give crafted item
        if (recipeName === 'healthpotion') {
          player.health = Math.min(player.maxHealth, player.health + 50);
        } else if (recipeName === 'boneclub') {
          player.weapon = 'boneclub';
          player.weaponAmmo += 15;
        } else if (recipeName === 'rapidfire') {
          player.weapon = 'rapidfire';
          player.weaponAmmo += 40;
        } else if (recipeName === 'acidgun') {
          player.weapon = 'acidgun';
          player.weaponAmmo += 20;
        } else if (recipeName === 'armor') {
          player.hasArmor = true;
          player.armorHits = 0;
        }
        
        return true;
      },
      
      draw(ctx, width, height) {
        if (!this.isOpen) return;
        
        // Semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, width, height);
        
        // Crafting window
        const boxW = 360, boxH = 230;
        const boxX = (width - boxW) / 2;
        const boxY = (height - boxH) / 2;
        
        ctx.fillStyle = '#2a3a2a';
        ctx.fillRect(boxX, boxY, boxW, boxH);
        ctx.strokeStyle = '#4a6a4a';
        ctx.lineWidth = 3;
        ctx.strokeRect(boxX, boxY, boxW, boxH);
        
        // Title
        ctx.fillStyle = '#fff';
        ctx.font = '12px "Press Start 2P", monospace';
        ctx.fillText('CRAFTING MENU', boxX + 10, boxY + 22);
        ctx.font = '7px "Press Start 2P", monospace';
        ctx.fillStyle = '#aaa';
        ctx.fillText('Up/Down: Select | Z: Craft | C: Close', boxX + 10, boxY + 36);

        // Recipes
        const recipes = [
          { name: 'Bone Club', key: 'boneclub', y: 50 },
          { name: 'Rapid Fire', key: 'rapidfire', y: 78 },
          { name: 'Acid Gun', key: 'acidgun', y: 106 },
          { name: 'Health Pot', key: 'healthpotion', y: 134 },
          { name: 'Armor', key: 'armor', y: 162 }
        ];

        for (let i = 0; i < recipes.length; i++) {
          const r = recipes[i];
          const canCraft = this.canCraft(r.key);
          const isSelected = i === this.selectedRecipe;

          // Background color based on craftability and selection
          if (isSelected) {
            ctx.fillStyle = canCraft ? '#5b5' : '#955';
          } else {
            ctx.fillStyle = canCraft ? '#4a4' : '#844';
          }
          ctx.fillRect(boxX + 10, boxY + r.y, boxW - 20, 22);

          // Selection border/highlight
          if (isSelected) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(boxX + 10, boxY + r.y, boxW - 20, 22);
          }

          // Selection arrow and recipe name
          ctx.fillStyle = '#fff';
          ctx.font = '8px "Press Start 2P", monospace';
          if (isSelected) {
            ctx.fillText('>', boxX + 14, boxY + r.y + 13);
          }
          ctx.fillText(r.name, boxX + 28, boxY + r.y + 13);

          // Show recipe requirements
          const recipe = CONFIG.RECIPES[r.key];
          let reqText = '';
          for (let item in recipe) {
            reqText += `${item}:${recipe[item]} `;
          }
          ctx.font = '6px "Press Start 2P", monospace';
          ctx.fillStyle = '#ccc';
          ctx.fillText(reqText, boxX + 120, boxY + r.y + 13);

          // Show craft prompt only for selected item
          if (isSelected && canCraft) {
            ctx.fillStyle = '#afa';
            ctx.font = '7px "Press Start 2P", monospace';
            ctx.fillText('[Z]', boxX + boxW - 45, boxY + r.y + 13);
          }
        }
      }
    };

    // ============================================
    // GAME STATS
    // ============================================
    const GameStats = {
      distance: 0,
      enemiesDefeated: 0,
      highScore: 0,
      currentScore: 0,

      init() {
        const saved = localStorage.getItem('dinoSurvivalHighScore');
        if (saved) this.highScore = parseInt(saved);
      },

      reset() {
        this.distance = 0;
        this.enemiesDefeated = 0;
        this.currentScore = 0;
      },

      updateDistance(playerX) {
        this.distance = Math.floor(playerX / 10);
        this.currentScore = this.distance + (this.enemiesDefeated * 100);
      },

      defeatEnemy() {
        this.enemiesDefeated++;
        this.currentScore = this.distance + (this.enemiesDefeated * 100);
      },

      saveHighScore() {
        if (this.currentScore > this.highScore) {
          this.highScore = this.currentScore;
          localStorage.setItem('dinoSurvivalHighScore', this.highScore.toString());
        }
      },

      getDifficultyMultiplier(playerX) {
        if (playerX < CONFIG.DIFFICULTY_SCALE_START) return 1.0;
        const excess = playerX - CONFIG.DIFFICULTY_SCALE_START;
        return 1.0 + (excess * CONFIG.DIFFICULTY_SCALE_RATE);
      }
    };

    // ============================================
    // COLOR PALETTES
    // ============================================
    const PALETTE = {
      skyTop: '#5a9fd4', skyMid: '#8ec5e8', skyBottom: '#b8ddf0', skyHorizon: '#d4eef8',
      cloudLight: '#ffffff', cloudMid: '#e8f4f8', cloudShadow: '#c8dce8',
      mountainFar: '#7a9ab0', mountainMid: '#6a8a98', mountainNear: '#5a7a6a', mountainSnow: '#e8f0f0',
      jungleFar: '#2a5a3a', jungleMid: '#3a7a4a', jungleNear: '#4a9a5a',
      trunkDark: '#3a2a1a', trunkMid: '#5a4030', trunkLight: '#7a5a40', palmTrunk: '#6a5040',
      leafDark: '#1a5a2a', leafMid: '#2a8a3a', leafLight: '#4aba4a', leafHighlight: '#6ada5a',
      palmLeaf: '#3a8a3a', palmLeafLight: '#5aaa4a',
      grassTop: '#4a9a3a', grassMid: '#3a7a2a', grassDark: '#2a5a1a',
      dirtLight: '#8a7050', dirtMid: '#6a5040', dirtDark: '#4a3a2a',
      stoneDark: '#4a4a4a', stoneMid: '#6a6a6a', stoneLight: '#8a8a8a', stoneHighlight: '#9a9a9a',
      waterDeep: '#2a5a8a', waterMid: '#4a8aba', waterLight: '#6aaada', waterSurface: '#8acaea',
      waterFoam: '#c8e8f8', waterShine: '#ffffff',
      flowerRed: '#da4a5a', flowerPink: '#ea8aaa', flowerYellow: '#eaca4a', flowerWhite: '#f8f8f0',
      mushroomCap: '#ca6a5a', mushroomCapLight: '#da8a7a', mushroomStem: '#e8e0d0',
      logDark: '#4a3020', logMid: '#6a4a30', logLight: '#8a6a40',
      rockDark: '#5a5a5a', rockMid: '#7a7a7a', rockLight: '#9a9a9a',
      berry: '#aa3a5a', berryLight: '#cc5a7a', meat: '#8a3a3a', meatLight: '#aa5a5a',
    };

    const RAPTOR_COLORS = {
      scalesDark: '#2d4a3d', scalesMid: '#3d6a4d', scalesLight: '#4d8a5d', scalesHighlight: '#6aaa6a',
      bellyDark: '#8a7a5a', bellyMid: '#aa9a6a', bellyLight: '#caba8a',
      stripeDark: '#1a3a2a', stripeAccent: '#4a3a2a',
      eye: '#ffaa00', eyeRing: '#aa6600', pupil: '#1a1a1a', eyeShine: '#ffffff',
      clawDark: '#2a2a2a', clawLight: '#4a4a4a',
      teeth: '#f0f0e0', teethShadow: '#c0c0b0', tongue: '#aa4a5a',
    };

    const SPINO_COLORS = {
      scalesDark: '#3a4a5a', scalesMid: '#4a6070', scalesLight: '#5a7888', scalesHighlight: '#7a98a8',
      sailDark: '#8a3a2a', sailMid: '#aa5a3a', sailLight: '#ca7a4a', sailSpine: '#6a2a1a',
      bellyDark: '#7a7a6a', bellyMid: '#9a9a8a', bellyLight: '#babaa0',
      stripeDark: '#2a3a4a',
      eye: '#ff6600', eyeRing: '#aa4400', pupil: '#1a1a1a', eyeShine: '#ffffff',
      clawDark: '#2a2a2a', clawLight: '#4a4a4a', teeth: '#f0f0e0',
    };

    // ============================================
    // PARTICLE EFFECTS
    // ============================================
    class Particle {
      constructor(x, y, vx, vy, color, size, lifetime) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.color = color; this.size = size;
        this.lifetime = lifetime; this.maxLife = lifetime;
        this.gravity = 300;
      }
      update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vy += this.gravity * dt;
        this.lifetime -= dt;
        return this.lifetime <= 0;
      }
      draw(ctx, camera) {
        const sx = this.x - camera.x;
        const alpha = this.lifetime / this.maxLife;
        ctx.fillStyle = this.color.replace('1)', alpha + ')');
        ctx.fillRect(sx - this.size / 2, this.y - this.size / 2, this.size, this.size);
      }
    }

    class ParticleSystem {
      constructor() {
        this.particles = [];
      }
      
      createHitSparks(x, y) {
        for (let i = 0; i < 8; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 100 + Math.random() * 150;
          this.particles.push(new Particle(
            x, y,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed - 100,
            'rgba(255, 200, 100, 1)',
            3 + Math.random() * 2,
            0.3 + Math.random() * 0.2
          ));
        }
      }

      createWoodChips(x, y) {
        for (let i = 0; i < 6; i++) {
          const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI;
          const speed = 80 + Math.random() * 120;
          this.particles.push(new Particle(
            x + (Math.random() - 0.5) * 20, y,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed - 60,
            'rgba(140, 100, 60, 1)',
            3 + Math.random() * 3,
            0.4 + Math.random() * 0.3
          ));
        }
      }

      createStoneChips(x, y) {
        for (let i = 0; i < 6; i++) {
          const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI;
          const speed = 80 + Math.random() * 120;
          this.particles.push(new Particle(
            x + (Math.random() - 0.5) * 16, y,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed - 60,
            'rgba(160, 160, 160, 1)',
            3 + Math.random() * 3,
            0.4 + Math.random() * 0.3
          ));
        }
      }

      createBreakEffect(x, y, color) {
        for (let i = 0; i < 12; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 60 + Math.random() * 140;
          this.particles.push(new Particle(
            x, y,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed - 120,
            color,
            4 + Math.random() * 4,
            0.5 + Math.random() * 0.4
          ));
        }
      }

      createDeathCloud(x, y) {
        for (let i = 0; i < 15; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 50 + Math.random() * 100;
          this.particles.push(new Particle(
            x, y,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed - 150,
            'rgba(100, 80, 70, 1)',
            4 + Math.random() * 3,
            0.5 + Math.random() * 0.3
          ));
        }
      }

      update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          if (this.particles[i].update(dt)) {
            this.particles.splice(i, 1);
          }
        }
      }

      draw(ctx, camera) {
        for (const p of this.particles) {
          p.draw(ctx, camera);
        }
      }
    }

    // ============================================
    // INPUT
    // ============================================
    const Input = {
      keys: { left: false, right: false, up: false, down: false, jump: false, attack: false, shoot: false, eat: false, craft: false },
      attackPressed: false, shootPressed: false, eatPressed: false, craftPressed: false, upPressed: false, downPressed: false,
      init() {
        window.addEventListener('keydown', e => this.handleKey(e, true));
        window.addEventListener('keyup', e => this.handleKey(e, false));
        ['dpad-left', 'dpad-right', 'dpad-up', 'dpad-down'].forEach(id => this.setupTouch(id, id.split('-')[1]));
        this.setupTouch('btn-jump', 'jump');
        this.setupTouch('btn-attack', 'attack');
        this.setupTouch('btn-shoot', 'shoot');
        this.setupTouch('btn-eat', 'eat');
        this.setupTouch('btn-craft', 'craft');
        document.addEventListener('contextmenu', e => e.preventDefault());
      },
      handleKey(e, down) {
        const map = { 'ArrowLeft': 'left', 'KeyA': 'left', 'ArrowRight': 'right', 'KeyD': 'right',
          'ArrowUp': 'up', 'KeyW': 'up', 'ArrowDown': 'down', 'KeyS': 'down',
          'Space': 'jump', 'KeyZ': 'attack', 'KeyX': 'shoot', 'KeyE': 'eat', 'KeyC': 'craft' };
        if (map[e.code]) { e.preventDefault(); this.keys[map[e.code]] = down; }
      },
      setupTouch(id, key) {
        const el = document.getElementById(id);
        if (!el) return;
        const set = p => { this.keys[key] = p; el.classList.toggle('pressed', p); };
        el.addEventListener('touchstart', e => { e.preventDefault(); set(true); });
        el.addEventListener('touchend', e => { e.preventDefault(); set(false); });
        el.addEventListener('touchcancel', e => { e.preventDefault(); set(false); });
        el.addEventListener('mousedown', e => { e.preventDefault(); set(true); });
        el.addEventListener('mouseup', e => { e.preventDefault(); set(false); });
        el.addEventListener('mouseleave', () => set(false));
      },
      isAttackJustPressed() {
        if (this.keys.attack && !this.attackPressed) { this.attackPressed = true; return true; }
        if (!this.keys.attack) this.attackPressed = false;
        return false;
      },
      isShootJustPressed() {
        if (this.keys.shoot && !this.shootPressed) { this.shootPressed = true; return true; }
        if (!this.keys.shoot) this.shootPressed = false;
        return false;
      },
      isEatJustPressed() {
        if (this.keys.eat && !this.eatPressed) { this.eatPressed = true; return true; }
        if (!this.keys.eat) this.eatPressed = false;
        return false;
      },
      isCraftJustPressed() {
        if (this.keys.craft && !this.craftPressed) { this.craftPressed = true; return true; }
        if (!this.keys.craft) this.craftPressed = false;
        return false;
      },
      isUpJustPressed() {
        if (this.keys.up && !this.upPressed) { this.upPressed = true; return true; }
        if (!this.keys.up) this.upPressed = false;
        return false;
      },
      isDownJustPressed() {
        if (this.keys.down && !this.downPressed) { this.downPressed = true; return true; }
        if (!this.keys.down) this.downPressed = false;
        return false;
      }
    };

    // ============================================
    // SPRITE RENDERER
    // ============================================
    const SpriteRenderer = {
      px(ctx, x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
      },

      drawRaptor(ctx, state, animFrame, facing, attackPhase = 0, flashTimer = 0, hasArmor = false, deathPhase = 0) {
        const C = RAPTOR_COLORS;
        const time = Date.now() / 1000;
        const isWalking = state === 'walk';
        const isAttacking = state === 'attack';
        const isDying = state === 'dying';
        
        if (isDying) {
          ctx.save();
          ctx.translate(24, 28);
          ctx.rotate(deathPhase * Math.PI * 0.5);
          ctx.translate(-24, -28);
          ctx.globalAlpha = 1 - (deathPhase * 0.7);
        }
        
        const walkPhase = animFrame * Math.PI * 0.5;
        const bob = isWalking ? Math.sin(walkPhase * 2) * 3 : 0;
        const legAnim = isWalking ? Math.sin(walkPhase) * 8 : 0;
        const legAnimBack = isWalking ? Math.sin(walkPhase + Math.PI) * 8 : 0;
        const tailWag = isWalking ? Math.sin(walkPhase) * 5 : Math.sin(time * 2) * 1;
        const headBob = isWalking ? Math.sin(walkPhase * 2 + 0.5) * 2 : 0;
        const breathe = Math.sin(time * 2) * 1.5;
        const idleShift = !isWalking && !isAttacking ? Math.sin(time * 0.8) * 1 : 0;

        ctx.save();
        if (facing === -1) { ctx.scale(-1, 1); ctx.translate(-48, 0); }

        this.px(ctx, 2, 22 + bob + tailWag * 0.3, 8, 10, C.scalesMid);
        this.px(ctx, 3, 24 + bob + tailWag * 0.3, 6, 6, C.scalesLight);
        this.px(ctx, -1, 20 + bob + tailWag * 0.6, 6, 8, C.scalesMid);
        this.px(ctx, -4, 21 + bob + tailWag * 0.9, 5, 5, C.scalesDark);
        this.px(ctx, -7, 22 + bob + tailWag, 4, 4, C.scalesDark);

        this.px(ctx, 10, 34 + bob, 10, 8, C.scalesMid);
        const backLegY = 40 + bob + legAnimBack * 0.3;
        this.px(ctx, 8 + legAnimBack * 0.2, backLegY, 8, 10, C.scalesMid);
        const backFootY = 48 + bob + Math.max(0, -legAnimBack * 0.5);
        this.px(ctx, 6, backFootY, 12, 4, C.scalesDark);
        this.px(ctx, 5, backFootY + 2, 3, 3, C.clawDark);
        this.px(ctx, 13, backFootY + 2, 3, 3, C.clawDark);
        this.px(ctx, 16, backFootY - 2, 3, 5, C.clawLight);

        this.px(ctx, 10, 24 + bob + breathe + idleShift, 26, 16, C.scalesMid);
        this.px(ctx, 12, 26 + bob + breathe + idleShift, 22, 12, C.scalesLight);
        this.px(ctx, 14, 18 + bob + breathe, 22, 10, C.scalesMid);
        this.px(ctx, 16, 20 + bob + breathe, 18, 6, C.scalesLight);
        this.px(ctx, 18, 19 + bob + breathe, 14, 3, C.scalesHighlight);
        this.px(ctx, 16, 28 + bob + breathe, 4, 8, C.stripeDark);
        this.px(ctx, 24, 26 + bob + breathe, 4, 10, C.stripeDark);
        this.px(ctx, 32, 24 + bob + breathe, 3, 8, C.stripeDark);
        this.px(ctx, 16, 34 + bob + breathe * 1.5, 16, 6 + breathe * 0.5, C.bellyMid);
        this.px(ctx, 18, 35 + bob + breathe * 1.5, 12, 4, C.bellyLight);

        if (hasArmor) {
          ctx.fillStyle = 'rgba(100, 120, 140, 0.6)';
          ctx.fillRect(12, 22 + bob + breathe, 24, 14);
          ctx.fillStyle = '#8090a0';
          ctx.fillRect(14, 24 + bob + breathe, 4, 10);
          ctx.fillRect(26, 24 + bob + breathe, 4, 10);
        }

        this.px(ctx, 28, 34 + bob, 8, 6, C.scalesMid);
        const frontLegY = 38 + bob + legAnim * 0.3;
        this.px(ctx, 30 - legAnim * 0.2, frontLegY, 6, 10, C.scalesMid);
        const frontFootY = 46 + bob + Math.max(0, -legAnim * 0.5);
        this.px(ctx, 28, frontFootY, 10, 4, C.scalesDark);
        this.px(ctx, 27, frontFootY + 2, 3, 3, C.clawDark);
        this.px(ctx, 35, frontFootY + 2, 3, 3, C.clawDark);

        let armExtend = 0, armAngleY = 0;
        if (isAttacking && attackPhase > 0) {
          const slashNum = Math.floor(attackPhase * 3);
          const slashProgress = (attackPhase * 3) % 1;
          if (slashNum === 0) { armExtend = 10 + slashProgress * 6; armAngleY = -6 + slashProgress * 4; }
          else if (slashNum === 1) { armExtend = 12 + slashProgress * 4; armAngleY = 0; }
          else { armExtend = 10 + slashProgress * 6; armAngleY = 4 + slashProgress * 4; }
        }
        
        this.px(ctx, 32 + armExtend * 0.2, 24 + bob + armAngleY * 0.3, 6, 5, C.scalesMid);
        this.px(ctx, 36 + armExtend * 0.4, 22 + bob + armAngleY * 0.5, 8 + armExtend * 0.5, 4, C.scalesMid);
        if (armExtend > 5) {
          this.px(ctx, 48 + armExtend, 18 + bob + armAngleY, 5, 3, C.clawDark);
          this.px(ctx, 48 + armExtend, 22 + bob + armAngleY, 5, 3, C.clawDark);
          this.px(ctx, 48 + armExtend, 26 + bob + armAngleY, 5, 3, C.clawDark);
          this.px(ctx, 51 + armExtend, 20 + bob + armAngleY, 3, 2, C.clawLight);
        } else {
          this.px(ctx, 44, 20 + bob, 4, 3, C.clawDark);
          this.px(ctx, 44, 24 + bob, 4, 3, C.clawDark);
        }

        this.px(ctx, 32, 12 + bob + breathe + headBob * 0.5, 10, 14, C.scalesMid);
        this.px(ctx, 34, 14 + bob + breathe + headBob * 0.5, 6, 10, C.scalesLight);
        this.px(ctx, 35, 16 + bob + breathe + headBob * 0.5, 4, 6, C.scalesHighlight);

        const headY = 4 + bob + headBob;
        this.px(ctx, 34, headY, 16, 14, C.scalesMid);
        this.px(ctx, 36, headY + 2, 12, 10, C.scalesLight);
        this.px(ctx, 46, headY + 4, 8, 8, C.scalesMid);
        this.px(ctx, 47, headY + 5, 6, 5, C.scalesLight);
        this.px(ctx, 44, headY + 2, 8, 3, C.scalesDark);
        this.px(ctx, 42, headY + 10, 12, 5, C.scalesMid);
        this.px(ctx, 49, headY + 11, 2, 3, C.teeth);
        this.px(ctx, 52, headY + 11, 2, 2, C.teeth);
        this.px(ctx, 38, headY + 2, 8, 8, C.scalesDark);
        this.px(ctx, 39, headY + 3, 6, 6, C.eyeRing);
        this.px(ctx, 40, headY + 4, 4, 4, C.eye);
        this.px(ctx, 42, headY + 4, 2, 4, C.pupil);
        this.px(ctx, 40, headY + 4, 1, 1, C.eyeShine);

        ctx.restore();

        if (isDying) ctx.restore();

        if (flashTimer > 0) {
          ctx.save();
          ctx.globalCompositeOperation = 'source-atop';
          ctx.fillStyle = `rgba(255, 50, 50, ${flashTimer * 2})`;
          ctx.fillRect(0, 0, 60, 56);
          ctx.restore();
        }
      },

      drawBabySpino(ctx, state, animFrame, facing, flashTimer = 0, deathPhase = 0) {
        const C = SPINO_COLORS;
        const time = Date.now() / 1000;
        const isWalking = state === 'walk' || state === 'chase';
        const isAttacking = state === 'attack';
        const isDying = state === 'dying';
        
        if (isDying) {
          ctx.save();
          ctx.translate(25, 40);
          ctx.rotate(deathPhase * Math.PI * 0.5);
          ctx.translate(-25, -40);
          ctx.globalAlpha = 1 - (deathPhase * 0.7);
        }

        const walkPhase = animFrame * Math.PI * 0.5;
        const bob = isWalking ? Math.sin(walkPhase * 2) * 2 : 0;
        const legAnim = isWalking ? Math.sin(walkPhase) * 6 : 0;
        const legAnimBack = isWalking ? Math.sin(walkPhase + Math.PI) * 6 : 0;
        const tailWag = isWalking ? Math.sin(walkPhase) * 4 : Math.sin(time * 2) * 1;
        const breathe = Math.sin(time * 2.5) * 1;

        ctx.save();
        if (facing === -1) { ctx.scale(-1, 1); ctx.translate(-50, 0); }

        this.px(ctx, -4, 26 + bob + tailWag, 10, 6, C.scalesMid);
        this.px(ctx, 4, 24 + bob + tailWag * 0.6, 8, 8, C.scalesMid);

        this.px(ctx, 12, 34 + bob, 8, 7, C.scalesMid);
        this.px(ctx, 10, 40 + bob + legAnimBack * 0.3, 7, 10, C.scalesMid);
        this.px(ctx, 8, 48 + bob + Math.max(0, -legAnimBack * 0.4), 10, 4, C.scalesDark);
        this.px(ctx, 7, 50 + bob, 3, 3, C.clawDark);
        this.px(ctx, 15, 50 + bob, 3, 3, C.clawDark);

        this.px(ctx, 10, 26 + bob + breathe, 24, 14, C.scalesMid);
        this.px(ctx, 12, 28 + bob + breathe, 20, 10, C.scalesLight);
        this.px(ctx, 14, 20 + bob + breathe, 20, 10, C.scalesMid);
        this.px(ctx, 16, 34 + bob + breathe, 14, 5, C.bellyMid);

        for (let i = 0; i < 6; i++) {
          const sh = 12 + Math.sin(i * 0.8) * 4;
          this.px(ctx, 14 + i * 4, 10 + bob - sh + breathe, 2, sh, C.sailSpine);
        }
        this.px(ctx, 14, 6 + bob + breathe, 24, 14, C.sailMid);
        this.px(ctx, 16, 8 + bob + breathe, 20, 10, C.sailLight);
        this.px(ctx, 18, 10 + bob + breathe, 2, 6, C.sailDark);
        this.px(ctx, 24, 8 + bob + breathe, 2, 8, C.sailDark);

        this.px(ctx, 28, 34 + bob, 6, 5, C.scalesMid);
        this.px(ctx, 29, 38 + bob + legAnim * 0.3, 5, 10, C.scalesMid);
        this.px(ctx, 27, 46 + bob + Math.max(0, -legAnim * 0.4), 8, 4, C.scalesDark);
        this.px(ctx, 26, 48 + bob, 3, 3, C.clawDark);
        this.px(ctx, 33, 48 + bob, 3, 3, C.clawDark);

        const armExt = isAttacking ? 5 : 0;
        this.px(ctx, 32 + armExt * 0.3, 28 + bob, 4, 4, C.scalesMid);
        this.px(ctx, 35 + armExt * 0.6, 27 + bob, 5 + armExt * 0.3, 3, C.scalesMid);

        this.px(ctx, 32, 18 + bob + breathe, 8, 14, C.scalesMid);

        const biteOpen = isAttacking ? 4 : 0;
        this.px(ctx, 36, 14 + bob, 12, 10, C.scalesMid);
        this.px(ctx, 46, 16 + bob - biteOpen * 0.2, 12, 6, C.scalesMid);
        this.px(ctx, 44, 22 + bob + biteOpen, 14, 4, C.scalesMid);
        this.px(ctx, 48, 22 + bob, 2, 3, C.teeth);
        this.px(ctx, 52, 22 + bob, 2, 2, C.teeth);
        this.px(ctx, 38, 14 + bob, 6, 6, C.scalesDark);
        this.px(ctx, 39, 15 + bob, 4, 4, C.eyeRing);
        this.px(ctx, 40, 16 + bob, 3, 3, C.eye);
        this.px(ctx, 41, 16 + bob, 2, 3, C.pupil);
        this.px(ctx, 40, 16 + bob, 1, 1, C.eyeShine);

        ctx.restore();

        if (isDying) ctx.restore();

        if (flashTimer > 0) {
          ctx.save();
          ctx.globalCompositeOperation = 'source-atop';
          ctx.fillStyle = `rgba(255, 50, 50, ${flashTimer * 2})`;
          ctx.fillRect(0, 0, 45, 40);
          ctx.restore();
        }
      }
    };

    // ============================================
    // BACKGROUND
    // ============================================
    const Background = {
      trees: [], rocks: [], bushes: [], puddles: [], ponds: [],
      flowers: [], mushrooms: [], logs: [], clouds: [], palmTrees: [],
      // NEW Phase 9 - Environmental features
      waterfalls: [], caves: [], cliffs: [], hollowLogs: [], treeRoots: [], rockFormations: [],
      
      init() {
        for (let i = 0; i < 8; i++) {
          this.clouds.push({ x: i * 400 + Math.random() * 200, y: 20 + Math.random() * 40, 
                            size: 30 + Math.random() * 40, speed: 5 + Math.random() * 10 });
        }
        for (let i = 0; i < 60; i++) {
          this.trees.push({ x: i * 100 + Math.random() * 50, height: 50 + Math.random() * 30,
                           width: 30 + Math.random() * 15, type: Math.floor(Math.random() * 3),
                           hp: 3, maxHp: 3, shakeTimer: 0, broken: false, respawnTimer: 0 });
        }
        for (let i = 0; i < 20; i++) {
          this.palmTrees.push({ x: 150 + i * 200 + Math.random() * 100, height: 60 + Math.random() * 20 });
        }
        for (let i = 0; i < 35; i++) {
          this.rocks.push({ x: i * 140 + Math.random() * 80, size: 10 + Math.random() * 15,
                           hp: 3, maxHp: 3, shakeTimer: 0, broken: false, respawnTimer: 0 });
        }
        for (let i = 0; i < 70; i++) {
          const types = ['red', 'pink', 'yellow', 'white'];
          this.flowers.push({ x: i * 60 + Math.random() * 40, type: types[Math.floor(Math.random() * 4)] });
        }
        for (let i = 0; i < 28; i++) {
          this.mushrooms.push({ x: 80 + i * 150 + Math.random() * 80, size: 6 + Math.random() * 4 });
        }
        for (let i = 0; i < 18; i++) {
          this.logs.push({ x: 200 + i * 250 + Math.random() * 100, length: 20 + Math.random() * 15 });
        }
        for (let i = 0; i < 28; i++) {
          this.bushes.push({ x: 200 + i * 140 + Math.random() * 60, collected: false });
        }
        for (let i = 0; i < 16; i++) {
          this.puddles.push({ x: 300 + i * 220 + Math.random() * 100, collected: false, respawnTimer: 0 });
        }
        this.ponds.push({ x: 500, points: this.generatePondShape(90, 35) });
        this.ponds.push({ x: 1300, points: this.generatePondShape(110, 40) });
        this.ponds.push({ x: 2200, points: this.generatePondShape(80, 30) });
        this.ponds.push({ x: 3400, points: this.generatePondShape(95, 38) });
        
        // NEW Phase 9 - Environmental features
        this.waterfalls.push({ x: 1000, height: 80 });
        this.waterfalls.push({ x: 2500, height: 100 });
        this.waterfalls.push({ x: 4200, height: 90 });
        
        this.caves.push({ x: 800, width: 60 });
        this.caves.push({ x: 2100, width: 70 });
        this.caves.push({ x: 3800, width: 65 });
        
        for (let i = 0; i < 5; i++) {
          this.cliffs.push({ x: 600 + i * 800, width: 120, height: 40 });
        }
        
        for (let i = 0; i < 10; i++) {
          this.hollowLogs.push({ x: 350 + i * 450, length: 40 + Math.random() * 20 });
        }
        
        for (let i = 0; i < 8; i++) {
          this.treeRoots.push({ x: 400 + i * 600, size: 30 + Math.random() * 20 });
        }
        
        for (let i = 0; i < 12; i++) {
          this.rockFormations.push({ x: 500 + i * 400, rocks: 3 + Math.floor(Math.random() * 3) });
        }
      },

      generatePondShape(width, height) {
        const points = [];
        const segments = 16;
        for (let i = 0; i <= segments; i++) {
          const angle = (i / segments) * Math.PI * 2;
          const rx = width / 2 + Math.sin(i * 3.7) * 8 + Math.cos(i * 2.3) * 6;
          const ry = height / 2 + Math.sin(i * 2.9) * 5 + Math.cos(i * 4.1) * 4;
          points.push({ x: Math.cos(angle) * rx, y: Math.sin(angle) * ry * 0.4 });
        }
        return points;
      },

      draw(ctx, camera, width, height) {
        const P = PALETTE;
        const groundY = height - CONFIG.GROUND_HEIGHT;
        const stoneY = height - CONFIG.GROUND_STONE_HEIGHT;

        // Sky with day/night
        const skyColors = DayNight.getSkyColors();
        const skyGrad = ctx.createLinearGradient(0, 0, 0, groundY);
        skyGrad.addColorStop(0, skyColors.top);
        skyGrad.addColorStop(0.5, skyColors.mid);
        skyGrad.addColorStop(0.8, skyColors.bottom);
        skyGrad.addColorStop(1, skyColors.horizon);
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, width, groundY);

        // Stars and moon at night
        DayNight.drawStars(ctx, camera, width, height);
        DayNight.drawMoon(ctx, width, height);

        // Birds flying
        Birds.draw(ctx, camera);

        this.drawClouds(ctx, camera, width);
        this.drawMountains(ctx, camera, width, groundY);

        ctx.fillStyle = P.jungleFar;
        this.drawJungleLayer(ctx, camera, width, groundY, 0.25, 0.6);
        ctx.fillStyle = P.jungleMid;
        this.drawJungleLayer(ctx, camera, width, groundY, 0.4, 0.75);
        ctx.fillStyle = P.jungleNear;
        this.drawJungleLayer(ctx, camera, width, groundY, 0.55, 0.9);

        this.drawPalmTrees(ctx, camera, groundY, 0.6);
        this.drawTrees(ctx, camera, width, groundY);

        const grassGrad = ctx.createLinearGradient(0, groundY, 0, stoneY);
        grassGrad.addColorStop(0, P.grassTop);
        grassGrad.addColorStop(0.2, P.grassMid);
        grassGrad.addColorStop(0.5, P.dirtLight);
        grassGrad.addColorStop(0.8, P.dirtMid);
        grassGrad.addColorStop(1, P.dirtDark);
        ctx.fillStyle = grassGrad;
        ctx.fillRect(0, groundY, width, CONFIG.GROUND_HEIGHT - CONFIG.GROUND_STONE_HEIGHT);

        // Grass edge highlight
        ctx.fillStyle = P.leafHighlight;
        ctx.fillRect(0, groundY, width, 2);
        ctx.fillStyle = P.grassDark;
        ctx.fillRect(0, groundY + 3, width, 1);

        // Dirt texture dots
        const dirtOffset = (camera.x * 0.95) % 40;
        for (let dx = -dirtOffset; dx < width + 20; dx += 18) {
          const dy = groundY + 14 + Math.sin(dx * 0.7) * 4;
          ctx.fillStyle = 'rgba(90, 70, 40, 0.3)';
          ctx.fillRect(dx, dy, 3, 2);
          ctx.fillRect(dx + 8, dy + 6, 2, 2);
        }
        // Small pebbles in dirt
        for (let dx = -dirtOffset; dx < width + 20; dx += 30) {
          const dy = groundY + 20 + Math.sin(dx * 1.3) * 5;
          ctx.fillStyle = 'rgba(120, 110, 90, 0.25)';
          ctx.beginPath();
          ctx.arc(dx, dy, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }

        this.drawStoneBorder(ctx, camera, width, stoneY, height);
        this.drawPonds(ctx, camera, groundY);
        this.drawPuddles(ctx, camera, groundY);
        this.drawFlowers(ctx, camera, groundY);
        this.drawMushrooms(ctx, camera, groundY);
        this.drawLogs(ctx, camera, groundY);
        this.drawGrass(ctx, camera, width, groundY);
        this.drawRocks(ctx, camera, groundY);
        this.drawBushes(ctx, camera, groundY);
        
        // NEW Phase 9 - Environmental features
        this.drawWaterfalls(ctx, camera, groundY);
        this.drawCaves(ctx, camera, groundY);
        this.drawCliffs(ctx, camera, groundY);
        this.drawHollowLogs(ctx, camera, groundY);
        this.drawTreeRoots(ctx, camera, groundY);
        this.drawRockFormations(ctx, camera, groundY);
      },

      drawClouds(ctx, camera, width) {
        const P = PALETTE;
        const time = Date.now() / 1000;
        for (const cloud of this.clouds) {
          const sx = (cloud.x + time * cloud.speed) % (CONFIG.LEVEL_WIDTH + 400) - 200;
          const screenX = sx - camera.x * 0.1;
          if (screenX < -100 || screenX > width + 100) continue;
          
          ctx.fillStyle = P.cloudMid;
          ctx.beginPath();
          ctx.arc(screenX, cloud.y, cloud.size * 0.6, 0, Math.PI * 2);
          ctx.arc(screenX - cloud.size * 0.5, cloud.y + 5, cloud.size * 0.4, 0, Math.PI * 2);
          ctx.arc(screenX + cloud.size * 0.5, cloud.y + 3, cloud.size * 0.5, 0, Math.PI * 2);
          ctx.arc(screenX + cloud.size * 0.9, cloud.y + 8, cloud.size * 0.35, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = P.cloudLight;
          ctx.beginPath();
          ctx.arc(screenX - 5, cloud.y - 5, cloud.size * 0.4, 0, Math.PI * 2);
          ctx.arc(screenX + cloud.size * 0.4, cloud.y - 2, cloud.size * 0.35, 0, Math.PI * 2);
          ctx.fill();
        }
      },

      drawMountains(ctx, camera, width, groundY) {
        const P = PALETTE;
        const layers = [
          { parallax: 0.08, color: P.mountainFar, height: 90, spacing: 220 },
          { parallax: 0.12, color: P.mountainMid, height: 70, spacing: 170 },
          { parallax: 0.18, color: P.mountainNear, height: 55, spacing: 130 }
        ];
        for (const l of layers) {
          const offset = (camera.x * l.parallax) % l.spacing;
          for (let i = -1; i < width / l.spacing + 2; i++) {
            const mx = i * l.spacing - offset;
            const mh = l.height + Math.sin(i * 1.5) * 25;
            
            ctx.fillStyle = l.color;
            ctx.beginPath();
            ctx.moveTo(mx - l.spacing * 0.7, groundY);
            ctx.lineTo(mx, groundY - mh);
            ctx.lineTo(mx + l.spacing * 0.7, groundY);
            ctx.fill();
            
            if (l.height > 60) {
              ctx.fillStyle = P.mountainSnow;
              ctx.beginPath();
              ctx.moveTo(mx - 12, groundY - mh + 18);
              ctx.lineTo(mx, groundY - mh);
              ctx.lineTo(mx + 12, groundY - mh + 18);
              ctx.lineTo(mx + 5, groundY - mh + 15);
              ctx.lineTo(mx, groundY - mh + 20);
              ctx.lineTo(mx - 5, groundY - mh + 15);
              ctx.fill();
            }
          }
        }
      },

      drawJungleLayer(ctx, camera, width, groundY, parallax, heightFactor) {
        const offset = (camera.x * parallax) % 60;
        for (let i = -1; i < width / 30 + 2; i++) {
          const x = i * 30 - offset;
          const h = (35 + Math.sin(i * 2.3) * 15) * heightFactor;
          ctx.beginPath();
          ctx.arc(x + 15, groundY - h * 0.5, h * 0.45, 0, Math.PI * 2);
          ctx.fill();
        }
      },

      drawPalmTrees(ctx, camera, groundY, parallax) {
        const P = PALETTE;
        const offset = camera.x * parallax;
        const time = Date.now() / 1000;
        
        for (const palm of this.palmTrees) {
          const sx = palm.x - offset;
          if (sx < -60 || sx > CONFIG.CANVAS_WIDTH + 60) continue;
          
          ctx.fillStyle = P.palmTrunk;
          ctx.beginPath();
          ctx.moveTo(sx - 4, groundY);
          ctx.quadraticCurveTo(sx + 8, groundY - palm.height * 0.5, sx + 3, groundY - palm.height);
          ctx.lineTo(sx + 7, groundY - palm.height);
          ctx.quadraticCurveTo(sx + 12, groundY - palm.height * 0.5, sx + 4, groundY);
          ctx.fill();
          
          ctx.fillStyle = P.trunkDark;
          for (let j = 0; j < 5; j++) {
            const segY = groundY - palm.height * 0.2 * (j + 1);
            ctx.fillRect(sx - 2 + j * 0.5, segY, 8 - j * 0.3, 2);
          }
          
          const frondCount = 7;
          for (let j = 0; j < frondCount; j++) {
            const angle = (j / frondCount) * Math.PI * 2;
            const frondLen = 25 + Math.sin(j * 2) * 8;
            // Animate leaves gently
            const sway = Math.sin(time * 1.5 + j) * 0.1;
            
            ctx.fillStyle = j % 2 === 0 ? P.palmLeaf : P.palmLeafLight;
            ctx.beginPath();
            ctx.moveTo(sx + 5, groundY - palm.height);
            const endX = sx + 5 + Math.cos(angle + sway) * frondLen;
            const endY = groundY - palm.height + Math.sin(angle + sway) * frondLen * 0.6 - 5;
            ctx.quadraticCurveTo(sx + 5 + Math.cos(angle + sway) * frondLen * 0.5, 
                                 groundY - palm.height - 10,
                                 endX, endY);
            ctx.quadraticCurveTo(sx + 5 + Math.cos(angle + sway) * frondLen * 0.5,
                                 groundY - palm.height - 5,
                                 sx + 5, groundY - palm.height);
            ctx.fill();
          }
        }
      },

      drawTrees(ctx, camera, width, groundY) {
        const P = PALETTE;
        const offset = camera.x * 0.7;
        const time = Date.now() / 1000;

        for (const tree of this.trees) {
          if (tree.broken) {
            // Draw stump for broken trees
            const sx = tree.x - offset;
            if (sx < -60 || sx > width + 60) continue;
            const trunkW = tree.width * 0.25;
            ctx.fillStyle = P.trunkDark;
            ctx.fillRect(sx + tree.width * 0.35, groundY - 8, trunkW + 4, 8);
            ctx.fillStyle = P.trunkMid;
            ctx.fillRect(sx + tree.width * 0.37, groundY - 8, trunkW, 2);
            // Stump top with rings
            ctx.fillStyle = '#8a7050';
            ctx.beginPath();
            ctx.ellipse(sx + tree.width * 0.5, groundY - 8, trunkW * 0.6 + 2, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = P.trunkDark;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(sx + tree.width * 0.5, groundY - 8, trunkW * 0.3, 1.5, 0, 0, Math.PI * 2);
            ctx.stroke();
            continue;
          }
          const sx = tree.x - offset + (tree.shakeTimer > 0 ? (Math.sin(time * 40) * 3 * tree.shakeTimer) : 0);
          if (sx < -60 || sx > width + 60) continue;
          
          const trunkW = tree.width * 0.25;
          const trunkH = tree.height * 0.6;
          
          ctx.fillStyle = P.trunkDark;
          ctx.beginPath();
          ctx.moveTo(sx + tree.width * 0.35, groundY);
          ctx.lineTo(sx + tree.width * 0.35 - 2, groundY - trunkH);
          ctx.lineTo(sx + tree.width * 0.65 + 2, groundY - trunkH);
          ctx.lineTo(sx + tree.width * 0.65, groundY);
          ctx.fill();
          
          ctx.fillStyle = P.trunkMid;
          ctx.fillRect(sx + tree.width * 0.4, groundY - trunkH + 5, trunkW * 0.4, trunkH - 10);
          
          ctx.fillStyle = P.trunkDark;
          for (let i = 0; i < 4; i++) {
            ctx.fillRect(sx + tree.width * 0.38, groundY - trunkH * 0.2 * (i + 1), trunkW + 4, 2);
          }
          
          ctx.strokeStyle = P.trunkDark;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(sx + tree.width * 0.4, groundY - trunkH * 0.7);
          ctx.quadraticCurveTo(sx + tree.width * 0.1, groundY - trunkH * 0.8, sx + tree.width * 0.05, groundY - trunkH * 0.9);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(sx + tree.width * 0.6, groundY - trunkH * 0.6);
          ctx.quadraticCurveTo(sx + tree.width * 0.9, groundY - trunkH * 0.65, sx + tree.width * 0.95, groundY - trunkH * 0.75);
          ctx.stroke();
          
          const leafColors = [P.leafDark, P.leafMid, P.leafLight];
          
          // Animate leaves with gentle sway
          const leafSway = Math.sin(time * 0.8 + tree.x * 0.01) * 2;
          
          for (let layer = 0; layer < 3; layer++) {
            ctx.fillStyle = leafColors[layer];
            ctx.beginPath();
            ctx.arc(sx + tree.width * 0.5 + leafSway, groundY - tree.height + 10 + layer * 4, 
                   tree.width * 0.5 - layer * 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(sx + tree.width * 0.2 + leafSway * 0.5, groundY - tree.height + 20 + layer * 3, 
                   tree.width * 0.35 - layer * 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(sx + tree.width * 0.8 + leafSway * 0.5, groundY - tree.height + 18 + layer * 3, 
                   tree.width * 0.38 - layer * 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(sx + tree.width * 0.5 + leafSway, groundY - tree.height - 5 + layer * 5, 
                   tree.width * 0.3 - layer * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.fillStyle = P.leafHighlight;
          for (let i = 0; i < 6; i++) {
            const hx = sx + tree.width * (0.2 + Math.sin(i * 1.3) * 0.3 + 0.3) + leafSway;
            const hy = groundY - tree.height + 5 + Math.cos(i * 1.7) * 15;
            ctx.beginPath();
            ctx.arc(hx, hy, 4 + Math.sin(i) * 2, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Damage cracks on trunk
          if (tree.hp < tree.maxHp) {
            ctx.strokeStyle = '#1a1a0a';
            ctx.lineWidth = 2;
            const dmg = tree.maxHp - tree.hp;
            for (let d = 0; d < dmg; d++) {
              const cy = groundY - trunkH * (0.3 + d * 0.25);
              ctx.beginPath();
              ctx.moveTo(sx + tree.width * 0.35, cy);
              ctx.lineTo(sx + tree.width * 0.5, cy - 4);
              ctx.lineTo(sx + tree.width * 0.55, cy + 2);
              ctx.stroke();
            }
          }

          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.beginPath();
          ctx.ellipse(sx + tree.width * 0.5, groundY - 2, tree.width * 0.7, 4, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      },

      drawStoneBorder(ctx, camera, width, stoneY, height) {
        const P = PALETTE;
        const brickWidth = 20;
        const brickHeight = CONFIG.GROUND_STONE_HEIGHT;
        const offset = (camera.x * 0.95) % (brickWidth * 2);
        
        for (let i = -1; i < width / brickWidth + 2; i++) {
          const bx = i * brickWidth - offset;
          const row = Math.floor(i / 2) % 2;
          const offsetX = row * brickWidth * 0.5;
          
          ctx.fillStyle = P.stoneMid;
          ctx.fillRect(bx + offsetX % brickWidth, stoneY, brickWidth - 1, brickHeight - 1);
          ctx.fillStyle = P.stoneLight;
          ctx.fillRect(bx + offsetX % brickWidth, stoneY, brickWidth - 1, 2);
          ctx.fillRect(bx + offsetX % brickWidth, stoneY, 2, brickHeight - 1);
          ctx.fillStyle = P.stoneDark;
          ctx.fillRect(bx + offsetX % brickWidth + brickWidth - 3, stoneY + 2, 2, brickHeight - 3);
          ctx.fillRect(bx + offsetX % brickWidth + 2, stoneY + brickHeight - 3, brickWidth - 3, 2);
        }
      },

      drawPonds(ctx, camera, groundY) {
        const P = PALETTE;
        const time = Date.now() / 1000;
        
        for (const pond of this.ponds) {
          const sx = pond.x - camera.x;
          if (sx < -150 || sx > CONFIG.CANVAS_WIDTH + 150) continue;
          
          ctx.fillStyle = P.waterDeep;
          ctx.beginPath();
          ctx.moveTo(sx + pond.points[0].x, groundY + pond.points[0].y);
          for (let i = 1; i < pond.points.length; i++) {
            ctx.lineTo(sx + pond.points[i].x, groundY + pond.points[i].y);
          }
          ctx.closePath();
          ctx.fill();
          
          ctx.fillStyle = P.waterMid;
          ctx.beginPath();
          ctx.moveTo(sx + pond.points[0].x * 0.85, groundY + pond.points[0].y * 0.8);
          for (let i = 1; i < pond.points.length; i++) {
            ctx.lineTo(sx + pond.points[i].x * 0.85, groundY + pond.points[i].y * 0.8);
          }
          ctx.closePath();
          ctx.fill();
          
          ctx.fillStyle = P.waterSurface;
          ctx.beginPath();
          ctx.ellipse(sx, groundY - 2, 30 + Math.sin(time * 2) * 3, 6, 0, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = P.waterFoam;
          ctx.lineWidth = 1;
          for (let r = 0; r < 3; r++) {
            const ripplePhase = (time * 2 + r * 0.8) % 3;
            const rippleSize = ripplePhase * 15;
            const rippleAlpha = 1 - ripplePhase / 3;
            ctx.globalAlpha = rippleAlpha * 0.5;
            ctx.beginPath();
            ctx.ellipse(sx - 10 + r * 15, groundY - 1, rippleSize, rippleSize * 0.3, 0, 0, Math.PI * 2);
            ctx.stroke();
          }
          ctx.globalAlpha = 1;
          
          ctx.fillStyle = P.waterShine;
          ctx.fillRect(sx - 20 + Math.sin(time) * 5, groundY - 3, 4, 2);
          ctx.fillRect(sx + 15 + Math.cos(time * 1.3) * 4, groundY - 2, 3, 2);
        }
      },

      drawPuddles(ctx, camera, groundY) {
        const P = PALETTE;
        const time = Date.now() / 1000;
        for (const puddle of this.puddles) {
          if (puddle.collected) continue;
          const sx = puddle.x - camera.x;
          if (sx < -20 || sx > CONFIG.CANVAS_WIDTH + 20) continue;
          
          ctx.fillStyle = P.waterMid;
          ctx.beginPath();
          ctx.ellipse(sx, groundY + 2, 14 + Math.sin(time + puddle.x) * 2, 5, 0, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = P.waterSurface;
          ctx.beginPath();
          ctx.ellipse(sx - 3, groundY + 1, 6, 2, 0, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = P.waterShine;
          ctx.fillRect(sx - 5, groundY, 2, 1);
        }
      },

      drawFlowers(ctx, camera, groundY) {
        const P = PALETTE;
        const offset = camera.x * 0.9;
        for (const flower of this.flowers) {
          const sx = flower.x - offset;
          if (sx < -10 || sx > CONFIG.CANVAS_WIDTH + 10) continue;
          
          ctx.fillStyle = P.leafMid;
          ctx.fillRect(sx, groundY - 8, 2, 8);
          
          const colors = { red: P.flowerRed, pink: P.flowerPink, yellow: P.flowerYellow, white: P.flowerWhite };
          ctx.fillStyle = colors[flower.type];
          ctx.beginPath();
          ctx.arc(sx + 1, groundY - 10, 4, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = P.flowerYellow;
          ctx.beginPath();
          ctx.arc(sx + 1, groundY - 10, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      },

      drawMushrooms(ctx, camera, groundY) {
        const P = PALETTE;
        const offset = camera.x * 0.9;
        for (const mush of this.mushrooms) {
          const sx = mush.x - offset;
          if (sx < -15 || sx > CONFIG.CANVAS_WIDTH + 15) continue;
          
          ctx.fillStyle = P.mushroomStem;
          ctx.fillRect(sx - 2, groundY - mush.size, 4, mush.size);
          
          ctx.fillStyle = P.mushroomCap;
          ctx.beginPath();
          ctx.arc(sx, groundY - mush.size - 2, mush.size, Math.PI, 0);
          ctx.fill();
          
          ctx.fillStyle = P.mushroomCapLight;
          ctx.beginPath();
          ctx.arc(sx - 2, groundY - mush.size - 4, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(sx + 3, groundY - mush.size - 3, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      },

      drawLogs(ctx, camera, groundY) {
        const P = PALETTE;
        const offset = camera.x * 0.9;
        for (const log of this.logs) {
          const sx = log.x - offset;
          if (sx < -30 || sx > CONFIG.CANVAS_WIDTH + 30) continue;
          
          ctx.fillStyle = P.logMid;
          ctx.fillRect(sx, groundY - 6, log.length, 8);
          
          ctx.fillStyle = P.logLight;
          ctx.fillRect(sx, groundY - 6, log.length, 2);
          
          ctx.fillStyle = P.logDark;
          ctx.beginPath();
          ctx.ellipse(sx, groundY - 2, 4, 5, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = P.logLight;
          ctx.beginPath();
          ctx.arc(sx, groundY - 3, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      },

      drawGrass(ctx, camera, width, groundY) {
        const P = PALETTE;
        const offset = (camera.x * 0.95) % 10;
        const time = Date.now() / 1000;
        
        for (let i = 0; i < width + 20; i += 10) {
          const gx = i - offset;
          // Animated grass sway
          const sway = Math.sin(time * 2 + gx * 0.1) * 1.5;
          
          ctx.fillStyle = P.leafMid;
          ctx.fillRect(gx + sway * 0.3, groundY - 5, 2, 7);
          ctx.fillRect(gx + 4 + sway * 0.5, groundY - 7, 2, 9);
          ctx.fillStyle = P.leafLight;
          ctx.fillRect(gx + 2 + sway * 0.7, groundY - 9, 2, 11);
          ctx.fillRect(gx + 6 + sway * 0.4, groundY - 6, 2, 8);
        }
      },

      drawRocks(ctx, camera, groundY) {
        const P = PALETTE;
        const offset = camera.x * 0.9;
        const time = Date.now() / 1000;
        for (const rock of this.rocks) {
          if (rock.broken) {
            // Draw rubble for broken rocks
            const sx = rock.x - offset;
            if (sx < -20 || sx > CONFIG.CANVAS_WIDTH + 20) continue;
            ctx.fillStyle = P.rockDark;
            ctx.fillRect(sx - 4, groundY - 3, 5, 3);
            ctx.fillRect(sx + 3, groundY - 2, 3, 2);
            ctx.fillStyle = P.rockMid;
            ctx.fillRect(sx - 1, groundY - 2, 3, 2);
            continue;
          }
          const shake = rock.shakeTimer > 0 ? Math.sin(time * 40) * 2 * rock.shakeTimer : 0;
          const sx = rock.x - offset + shake;
          if (sx < -20 || sx > CONFIG.CANVAS_WIDTH + 20) continue;

          ctx.fillStyle = P.rockMid;
          ctx.beginPath();
          ctx.ellipse(sx, groundY - rock.size * 0.35, rock.size, rock.size * 0.55, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = P.rockLight;
          ctx.beginPath();
          ctx.ellipse(sx - rock.size * 0.25, groundY - rock.size * 0.55, rock.size * 0.4, rock.size * 0.25, -0.3, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = P.rockDark;
          ctx.beginPath();
          ctx.ellipse(sx + rock.size * 0.3, groundY - rock.size * 0.2, rock.size * 0.3, rock.size * 0.2, 0.2, 0, Math.PI * 2);
          ctx.fill();

          // Crack marks for damaged rocks
          if (rock.hp < rock.maxHp) {
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1.5;
            const dmg = rock.maxHp - rock.hp;
            for (let d = 0; d < dmg; d++) {
              ctx.beginPath();
              ctx.moveTo(sx - rock.size * 0.2 + d * 5, groundY - rock.size * 0.5);
              ctx.lineTo(sx + d * 3, groundY - rock.size * 0.15);
              ctx.lineTo(sx + rock.size * 0.1 + d * 4, groundY - rock.size * 0.4);
              ctx.stroke();
            }
          }
        }
      },

      drawBushes(ctx, camera, groundY) {
        const P = PALETTE;
        for (const bush of this.bushes) {
          if (bush.collected) continue;
          const sx = bush.x - camera.x;
          if (sx < -30 || sx > CONFIG.CANVAS_WIDTH + 30) continue;
          
          ctx.fillStyle = P.leafDark;
          ctx.beginPath();
          ctx.arc(sx, groundY - 10, 14, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = P.leafMid;
          ctx.beginPath();
          ctx.arc(sx - 5, groundY - 12, 9, 0, Math.PI * 2);
          ctx.arc(sx + 6, groundY - 11, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = P.leafLight;
          ctx.beginPath();
          ctx.arc(sx - 2, groundY - 14, 5, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = P.berry;
          ctx.beginPath();
          ctx.arc(sx - 7, groundY - 7, 3, 0, Math.PI * 2);
          ctx.arc(sx + 3, groundY - 6, 3, 0, Math.PI * 2);
          ctx.arc(sx + 9, groundY - 9, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = P.berryLight;
          ctx.beginPath();
          ctx.arc(sx - 8, groundY - 8, 1, 0, Math.PI * 2);
          ctx.arc(sx + 2, groundY - 7, 1, 0, Math.PI * 2);
          ctx.fill();
        }
      },
      
      // NEW Phase 9 - Environmental Features Drawing Methods
      drawWaterfalls(ctx, camera, groundY) {
        const time = Date.now() / 1000;
        for (const waterfall of this.waterfalls) {
          const sx = waterfall.x - camera.x * 0.8;
          if (sx < -80 || sx > CONFIG.CANVAS_WIDTH + 80) continue;
          
          // Rock cliff
          ctx.fillStyle = '#5a6a7a';
          ctx.fillRect(sx, groundY - waterfall.height, 15, waterfall.height);
          ctx.fillStyle = '#7a8a9a';
          ctx.fillRect(sx + 2, groundY - waterfall.height, 3, waterfall.height);
          
          // Animated water cascade
          for (let i = 0; i < 8; i++) {
            const dropY = ((time * 150 + i * 20) % waterfall.height);
            ctx.fillStyle = 'rgba(140, 200, 250, 0.7)';
            ctx.fillRect(sx + 6, groundY - waterfall.height + dropY, 4, 15);
          }
          
          // Splash pool at bottom
          ctx.fillStyle = '#4a8aba';
          ctx.beginPath();
          ctx.ellipse(sx + 8, groundY + 2, 20, 6, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#8acaea';
          ctx.beginPath();
          ctx.ellipse(sx + 8, groundY, 12, 4, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      },
      
      drawCaves(ctx, camera, groundY) {
        for (const cave of this.caves) {
          const sx = cave.x - camera.x * 0.9;
          if (sx < -100 || sx > CONFIG.CANVAS_WIDTH + 100) continue;
          
          // Cave entrance (dark arch)
          ctx.fillStyle = '#1a1a1a';
          ctx.beginPath();
          ctx.ellipse(sx + cave.width / 2, groundY - 5, cave.width / 2, cave.width / 3, 0, 0, Math.PI, true);
          ctx.fill();
          
          // Rock surrounding
          ctx.fillStyle = '#3a3a3a';
          ctx.beginPath();
          ctx.arc(sx, groundY - 10, cave.width / 3, 0, Math.PI);
          ctx.arc(sx + cave.width, groundY - 10, cave.width / 3, 0, Math.PI);
          ctx.fill();
          
          // Shadows and detail
          ctx.fillStyle = '#2a2a2a';
          ctx.fillRect(sx + cave.width * 0.3, groundY - cave.width * 0.2, cave.width * 0.4, cave.width * 0.2);
        }
      },
      
      drawCliffs(ctx, camera, groundY) {
        for (const cliff of this.cliffs) {
          const sx = cliff.x - camera.x * 0.85;
          if (sx < -150 || sx > CONFIG.CANVAS_WIDTH + 150) continue;
          
          // Platform/ledge
          ctx.fillStyle = '#6a5a4a';
          ctx.fillRect(sx, groundY - cliff.height, cliff.width, 12);
          ctx.fillStyle = '#5a4a3a';
          ctx.fillRect(sx, groundY - cliff.height + 12, cliff.width, 4);
          
          // Support rocks
          ctx.fillStyle = '#7a6a5a';
          ctx.fillRect(sx + 10, groundY - cliff.height, 8, cliff.height);
          ctx.fillRect(sx + cliff.width - 18, groundY - cliff.height, 8, cliff.height);
          
          // Grass on top
          ctx.fillStyle = PALETTE.grassMid;
          ctx.fillRect(sx, groundY - cliff.height, cliff.width, 2);
        }
      },
      
      drawHollowLogs(ctx, camera, groundY) {
        for (const log of this.hollowLogs) {
          const sx = log.x - camera.x * 0.9;
          if (sx < -60 || sx > CONFIG.CANVAS_WIDTH + 60) continue;
          
          // Log body
          ctx.fillStyle = PALETTE.logMid;
          ctx.fillRect(sx, groundY - 15, log.length, 18);
          ctx.fillStyle = PALETTE.logDark;
          ctx.fillRect(sx, groundY - 15, log.length, 3);
          ctx.fillRect(sx, groundY, log.length, 3);
          
          // Hollow opening
          ctx.fillStyle = '#2a2a2a';
          ctx.beginPath();
          ctx.ellipse(sx + 5, groundY - 7, 8, 10, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#3a3a3a';
          ctx.beginPath();
          ctx.ellipse(sx + 5, groundY - 7, 5, 7, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      },
      
      drawTreeRoots(ctx, camera, groundY) {
        for (const root of this.treeRoots) {
          const sx = root.x - camera.x * 0.9;
          if (sx < -50 || sx > CONFIG.CANVAS_WIDTH + 50) continue;
          
          // Large exposed roots
          ctx.strokeStyle = PALETTE.trunkDark;
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(sx, groundY - 20);
          ctx.quadraticCurveTo(sx - root.size * 0.3, groundY - 10, sx - root.size * 0.5, groundY + 5);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(sx, groundY - 20);
          ctx.quadraticCurveTo(sx + root.size * 0.3, groundY - 10, sx + root.size * 0.5, groundY + 5);
          ctx.stroke();
          
          ctx.lineWidth = 4;
          ctx.strokeStyle = PALETTE.trunkMid;
          ctx.beginPath();
          ctx.moveTo(sx - 10, groundY - 15);
          ctx.quadraticCurveTo(sx - 15, groundY - 5, sx - 20, groundY + 5);
          ctx.stroke();
        }
      },
      
      drawRockFormations(ctx, camera, groundY) {
        for (const formation of this.rockFormations) {
          const sx = formation.x - camera.x * 0.9;
          if (sx < -60 || sx > CONFIG.CANVAS_WIDTH + 60) continue;
          
          // Multiple stacked rocks
          for (let i = 0; i < formation.rocks; i++) {
            const rockSize = 12 + i * 4;
            const rockY = groundY - i * 10;
            
            ctx.fillStyle = PALETTE.rockMid;
            ctx.beginPath();
            ctx.ellipse(sx + i * 3, rockY - rockSize * 0.4, rockSize, rockSize * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = PALETTE.rockLight;
            ctx.beginPath();
            ctx.ellipse(sx + i * 3 - 3, rockY - rockSize * 0.6, rockSize * 0.4, rockSize * 0.3, -0.2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
    };

    // ============================================
    // PICKUPS & WEAPONS
    // ============================================
    class Pickup {
      constructor(x, y, type) {
        this.x = x; 
        this.y = y;
        this.type = type;
        this.width = 24; this.height = 24;
        this.collected = false;
        this.lifetime = 999;
      }
      update(dt) {
        return this.collected;
      }
      draw(ctx, camera) {
        if (this.collected) return;
        const sx = this.x - camera.x;
        const sy = this.y;
        if (sx < -40 || sx > CONFIG.CANVAS_WIDTH + 40) return;
        
        ctx.save();
        ctx.translate(sx, sy);
        
        // Glow effect
        const glowSize = 25 + Math.sin(Date.now() / 200) * 5;
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
        if (this.type === 'meat') {
          gradient.addColorStop(0, 'rgba(255, 100, 100, 0.5)');
          gradient.addColorStop(1, 'rgba(255, 100, 100, 0)');
        } else if (this.type === 'rapidfire') {
          gradient.addColorStop(0, 'rgba(100, 150, 255, 0.6)');
          gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
        } else if (this.type === 'acidgun') {
          gradient.addColorStop(0, 'rgba(100, 255, 100, 0.6)');
          gradient.addColorStop(1, 'rgba(100, 255, 100, 0)');
        } else if (this.type === 'boneclub') {
          gradient.addColorStop(0, 'rgba(255, 230, 180, 0.6)');
          gradient.addColorStop(1, 'rgba(255, 230, 180, 0)');
        } else if (this.type === 'armor') {
          gradient.addColorStop(0, 'rgba(150, 200, 255, 0.6)');
          gradient.addColorStop(1, 'rgba(150, 200, 255, 0)');
        } else if (this.type === 'egg') {
          gradient.addColorStop(0, 'rgba(255, 200, 100, 0.8)');
          gradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
        } else if (this.type === 'fossil') {
          gradient.addColorStop(0, 'rgba(200, 180, 150, 0.6)');
          gradient.addColorStop(1, 'rgba(200, 180, 150, 0)');
        } else if (this.type === 'crystal') {
          gradient.addColorStop(0, 'rgba(150, 100, 255, 0.9)');
          gradient.addColorStop(1, 'rgba(150, 100, 255, 0)');
        } else if (this.type === 'wood') {
          gradient.addColorStop(0, 'rgba(139, 90, 43, 0.5)');
          gradient.addColorStop(1, 'rgba(139, 90, 43, 0)');
        } else if (this.type === 'stone') {
          gradient.addColorStop(0, 'rgba(128, 128, 128, 0.5)');
          gradient.addColorStop(1, 'rgba(128, 128, 128, 0)');
        } else if (this.type === 'bones') {
          gradient.addColorStop(0, 'rgba(240, 230, 210, 0.6)');
          gradient.addColorStop(1, 'rgba(240, 230, 210, 0)');
        } else if (this.type === 'metal') {
          gradient.addColorStop(0, 'rgba(192, 192, 192, 0.7)');
          gradient.addColorStop(1, 'rgba(192, 192, 192, 0)');
        }
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.scale(1.5, 1.5);
        
        if (this.type === 'meat') {
          ctx.fillStyle = PALETTE.meat;
          ctx.fillRect(-6, -4, 12, 8);
          ctx.fillStyle = PALETTE.meatLight;
          ctx.fillRect(-4, -2, 8, 4);
          ctx.fillStyle = '#fff';
          ctx.fillRect(-2, -1, 3, 2);
          ctx.fillStyle = '#e0e0d0';
          ctx.fillRect(-8, -2, 4, 4);
          ctx.fillRect(4, -2, 4, 4);
        } else if (this.type === 'rapidfire') {
          ctx.fillStyle = '#3a5a7a';
          ctx.fillRect(-12, -4, 24, 8);
          ctx.fillStyle = '#5a7a9a';
          ctx.fillRect(-10, -3, 20, 6);
          ctx.fillStyle = '#8abadf';
          ctx.fillRect(-8, -2, 6, 4);
          ctx.fillStyle = '#ffa500';
          ctx.fillRect(10, -2, 4, 4);
        } else if (this.type === 'acidgun') {
          ctx.fillStyle = '#2a5a2a';
          ctx.fillRect(-12, -5, 24, 10);
          ctx.fillStyle = '#4a8a4a';
          ctx.fillRect(-10, -4, 20, 8);
          ctx.fillStyle = '#8afa8a';
          ctx.fillRect(-6, -3, 8, 6);
          ctx.fillStyle = '#4afa4a';
          ctx.fillRect(10, -2, 4, 6);
          ctx.fillRect(11, 4, 2, 3);
        } else if (this.type === 'boneclub') {
          ctx.fillStyle = '#8a7a6a';
          ctx.fillRect(-4, -2, 8, 16);
          ctx.fillStyle = '#d0c8b8';
          ctx.fillRect(-8, -12, 16, 12);
          ctx.fillStyle = '#e8e0d0';
          ctx.fillRect(-6, -10, 12, 8);
          ctx.fillStyle = '#a09080';
          ctx.fillRect(-7, -11, 3, 4);
          ctx.fillRect(4, -11, 3, 4);
        } else if (this.type === 'armor') {
          ctx.fillStyle = '#5070a0';
          ctx.fillRect(-9, -8, 18, 16);
          ctx.fillStyle = '#7090b0';
          ctx.fillRect(-7, -6, 14, 12);
          ctx.fillStyle = '#90b0d0';
          ctx.fillRect(-5, -4, 10, 8);
          ctx.fillStyle = '#b0d0f0';
          ctx.fillRect(-1, -6, 2, 12);
          ctx.fillRect(-5, -1, 10, 2);
        } else if (this.type === 'egg') {
          // Dinosaur egg - glowing, speckled
          ctx.fillStyle = '#e8c060';
          ctx.beginPath();
          ctx.ellipse(0, 0, 8, 10, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#f8d080';
          ctx.beginPath();
          ctx.ellipse(-2, -2, 5, 7, 0, 0, Math.PI * 2);
          ctx.fill();
          // Speckles
          ctx.fillStyle = '#a08050';
          ctx.fillRect(-3, -4, 2, 2);
          ctx.fillRect(2, -6, 2, 2);
          ctx.fillRect(-1, 3, 2, 2);
        } else if (this.type === 'fossil') {
          // Fossil bone
          ctx.fillStyle = '#b8a890';
          ctx.fillRect(-8, -2, 16, 4);
          ctx.beginPath();
          ctx.arc(-8, 0, 3, 0, Math.PI * 2);
          ctx.arc(8, 0, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#c8b8a0';
          ctx.fillRect(-6, -1, 12, 2);
        } else if (this.type === 'crystal') {
          // Crystal shard - purple/blue
          ctx.fillStyle = '#8060d0';
          ctx.beginPath();
          ctx.moveTo(0, -10);
          ctx.lineTo(-6, 4);
          ctx.lineTo(6, 4);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#a080f0';
          ctx.beginPath();
          ctx.moveTo(0, -10);
          ctx.lineTo(-3, 0);
          ctx.lineTo(3, 0);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#c0a0ff';
          ctx.fillRect(-1, -6, 2, 8);
        } else if (this.type === 'wood') {
          // Wood log piece
          ctx.fillStyle = '#8b5a2b';
          ctx.fillRect(-6, -4, 12, 8);
          ctx.fillStyle = '#a0692f';
          ctx.fillRect(-5, -3, 10, 6);
          // Rings
          ctx.strokeStyle = '#7a4a1b';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(-2, 0, 2, 0, Math.PI * 2);
          ctx.arc(2, 0, 1.5, 0, Math.PI * 2);
          ctx.stroke();
        } else if (this.type === 'stone') {
          // Stone chunk
          ctx.fillStyle = '#808080';
          ctx.fillRect(-6, -5, 12, 10);
          ctx.fillStyle = '#a0a0a0';
          ctx.fillRect(-5, -4, 8, 6);
          ctx.fillStyle = '#606060';
          ctx.fillRect(-3, -2, 6, 4);
        } else if (this.type === 'bones') {
          // Bone
          ctx.fillStyle = '#f0e6d2';
          ctx.fillRect(-8, -2, 16, 4);
          ctx.beginPath();
          ctx.arc(-8, 0, 3, 0, Math.PI * 2);
          ctx.arc(8, 0, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#fff';
          ctx.fillRect(-6, -1, 12, 2);
        } else if (this.type === 'metal') {
          // Metal scrap
          ctx.fillStyle = '#c0c0c0';
          ctx.beginPath();
          ctx.moveTo(0, -8);
          ctx.lineTo(6, -2);
          ctx.lineTo(4, 6);
          ctx.lineTo(-4, 6);
          ctx.lineTo(-6, -2);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#e0e0e0';
          ctx.fillRect(-3, -4, 6, 8);
        }
        
        ctx.scale(1/1.5, 1/1.5);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        const sparkleTime = Date.now() / 150;
        ctx.fillRect(-15 + Math.sin(sparkleTime) * 5, -18, 3, 3);
        ctx.fillRect(12 + Math.cos(sparkleTime * 1.3) * 5, -15, 3, 3);
        
        ctx.restore();
      }
      getHitbox() { return { x: this.x - 20, y: this.y - 20, width: 40, height: 40 }; }
    }

    class Bullet {
      constructor(x, y, vx, vy, damage, type = 'rapid') {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.damage = damage; this.type = type; this.dead = false;
      }
      update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        if (this.type === 'acid') this.vy += 150 * dt;
        if (this.x < 0 || this.x > CONFIG.LEVEL_WIDTH || this.y < 0 || this.y > CONFIG.CANVAS_HEIGHT) {
          this.dead = true;
        }
        return this.dead;
      }
      draw(ctx, camera) {
        const sx = this.x - camera.x;
        const sy = this.y;
        if (sx < -10 || sx > CONFIG.CANVAS_WIDTH + 10) return;
        
        if (this.type === 'acid') {
          ctx.fillStyle = '#2a8a2a';
          ctx.beginPath();
          ctx.arc(sx, sy, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#4afa4a';
          ctx.beginPath();
          ctx.arc(sx, sy, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#8afa8a';
          ctx.beginPath();
          ctx.arc(sx - 1, sy - 1, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = 'rgba(74, 250, 74, 0.5)';
          ctx.beginPath();
          ctx.arc(sx - this.vx * 0.02, sy - 3, 2, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillStyle = '#ff8800';
          ctx.beginPath();
          ctx.arc(sx, sy, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#ffcc00';
          ctx.beginPath();
          ctx.arc(sx, sy, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      getHitbox() { return { x: this.x - 5, y: this.y - 5, width: 10, height: 10 }; }
    }

    // Due to length limitations, I'll continue with Player, Enemy, and remaining systems in the response...
    // [Continuing from where we left off...]

    // ============================================
    // PLAYER
    // ============================================
    class Player {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.width = 48; this.height = 52;
        this.vx = 0; this.vy = 0;
        this.grounded = false; this.facing = 1;
        this.state = 'idle';
        this.attackTimer = 0; this.attackPhase = 0;
        this.animFrame = 0; this.animTimer = 0;
        this.health = CONFIG.PLAYER_MAX_HEALTH;
        this.maxHealth = CONFIG.PLAYER_MAX_HEALTH;
        this.flashTimer = 0; this.invulnTimer = 0;
        this.dead = false; this.deathTimer = 0;
        this.hunger = CONFIG.MAX_HUNGER;
        this.thirst = CONFIG.MAX_THIRST;
        this.isSlowed = false;
        this.weapon = null;
        this.weaponAmmo = 0;
        this.shootCooldown = 0;
        this.hasArmor = false;
        this.armorHits = 0;
        this.clubSwinging = false;
        this.clubTimer = 0;
      }

      takeDamage(amount) {
        if (this.invulnTimer > 0 || this.dead) return;
        if (this.hasArmor) {
          amount = Math.floor(amount * 0.5);
          this.armorHits++;
          if (this.armorHits >= 5) { this.hasArmor = false; this.armorHits = 0; }
        }
        this.health -= amount;
        this.flashTimer = 0.3;
        this.invulnTimer = 0.5;
        if (this.health <= 0) { 
          this.health = 0; 
          this.dead = true; 
          this.state = 'dying';
          this.deathTimer = CONFIG.DEATH_ANIMATION_TIME;
        }
      }

      restoreHunger(amt) { this.hunger = Math.min(CONFIG.MAX_HUNGER, this.hunger + amt); }
      restoreThirst(amt) { this.thirst = Math.min(CONFIG.MAX_THIRST, this.thirst + amt); }

      update(dt) {
        if (this.dead) {
          this.deathTimer -= dt;
          return;
        }
        
        const C = CONFIG;

        if (this.flashTimer > 0) this.flashTimer -= dt;
        if (this.invulnTimer > 0) this.invulnTimer -= dt;
        if (this.shootCooldown > 0) this.shootCooldown -= dt;
        if (this.clubTimer > 0) this.clubTimer -= dt;
        else this.clubSwinging = false;

        this.hunger -= C.HUNGER_DRAIN * dt;
        this.thirst -= C.THIRST_DRAIN * dt;
        this.hunger = Math.max(0, this.hunger);
        this.thirst = Math.max(0, this.thirst);

        this.isSlowed = this.hunger <= 0 || this.thirst <= 0;
        if (this.hunger <= 0) this.health -= C.STARVATION_DAMAGE * dt;
        if (this.thirst <= 0) this.health -= C.DEHYDRATION_DAMAGE * dt;
        
        if (this.hunger >= C.MAX_HUNGER && this.thirst >= C.MAX_THIRST && this.health < this.maxHealth) {
          this.health = Math.min(this.maxHealth, this.health + C.HP_REGEN_RATE * dt);
        }
        
        if (this.health <= 0) { 
          this.health = 0; 
          this.dead = true; 
          this.state = 'dying';
          this.deathTimer = CONFIG.DEATH_ANIMATION_TIME;
        }

        const speed = this.isSlowed ? C.PLAYER_SPEED_SLOW : C.PLAYER_SPEED;
        let moveDir = 0;
        if (Input.keys.left) moveDir -= 1;
        if (Input.keys.right) moveDir += 1;

        if (moveDir !== 0) {
          this.facing = moveDir;
          this.vx += moveDir * C.PLAYER_ACCELERATION * dt;
          this.vx = Math.max(-speed, Math.min(speed, this.vx));
        } else {
          if (this.vx > 0) this.vx = Math.max(0, this.vx - C.PLAYER_FRICTION * dt);
          else if (this.vx < 0) this.vx = Math.min(0, this.vx + C.PLAYER_FRICTION * dt);
        }

        if (Input.keys.jump && this.grounded) {
          this.vy = -C.JUMP_FORCE;
          this.grounded = false;
        }

        this.vy += C.GRAVITY * dt;
        this.vy = Math.min(this.vy, C.MAX_FALL_SPEED);
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        const groundY = C.CANVAS_HEIGHT - C.GROUND_HEIGHT;
        const scaledHeight = this.height * CONFIG.PLAYER_SCALE;
        if (this.y + scaledHeight > groundY) {
          this.y = groundY - scaledHeight;
          this.vy = 0;
          this.grounded = true;
        }

        if (this.x < 0) { this.x = 0; this.vx = 0; }
        if (this.x + this.width > C.LEVEL_WIDTH) { this.x = C.LEVEL_WIDTH - this.width; this.vx = 0; }

        if (Input.isAttackJustPressed() && this.attackTimer <= 0 && !this.clubSwinging) {
          if (this.weapon === 'boneclub' && this.weaponAmmo > 0) {
            this.swingClub();
          } else {
            this.attackTimer = 0.45;
            this.attackPhase = 0;
            this.state = 'attack';
          }
        }

        if (this.attackTimer > 0) {
          this.attackTimer -= dt;
          this.attackPhase = 1 - (this.attackTimer / 0.45);
        }

        this.animTimer += dt;
        if (this.animTimer > 0.1) {
          this.animTimer = 0;
          this.animFrame = (this.animFrame + 1) % 4;
        }

        if (this.attackTimer > 0) this.state = 'attack';
        else if (!this.grounded) this.state = 'jump';
        else if (Math.abs(this.vx) > 10) this.state = 'walk';
        else this.state = 'idle';
      }

      shoot(bullets) {
        if (!this.weapon || this.shootCooldown > 0) return;
        if (this.weapon === 'boneclub') return;
        if (this.weaponAmmo <= 0) { this.weapon = null; return; }
        
        const C = CONFIG;
        const scale = C.PLAYER_SCALE;
        const bx = this.x + (this.facing === 1 ? this.width * scale : 0);
        const by = this.y + 35 * scale;
        
        if (this.weapon === 'rapidfire') {
          bullets.push(new Bullet(bx, by, this.facing * C.BULLET_SPEED, 0, C.RAPID_DAMAGE, 'rapid'));
          this.shootCooldown = C.RAPID_FIRE_RATE;
          this.weaponAmmo--;
        } else if (this.weapon === 'acidgun') {
          bullets.push(new Bullet(bx, by, this.facing * C.BULLET_SPEED * 0.8, 0, C.ACID_DAMAGE, 'acid'));
          this.shootCooldown = C.ACID_FIRE_RATE;
          this.weaponAmmo--;
        }
        
        if (this.weaponAmmo <= 0) this.weapon = null;
      }

      swingClub() {
        if (this.weapon !== 'boneclub' || this.clubSwinging || this.weaponAmmo <= 0) return false;
        this.clubSwinging = true;
        this.clubTimer = CONFIG.BONE_CLUB_RATE;
        this.weaponAmmo--;
        if (this.weaponAmmo <= 0) this.weapon = null;
        return true;
      }

      draw(ctx, camera) {
        const sx = this.x - camera.x;
        const sy = this.y - camera.y;
        const scale = CONFIG.PLAYER_SCALE;
        
        ctx.save();
        ctx.translate(sx, sy);
        ctx.scale(scale, scale);
        
        if (this.flashTimer > 0) ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.05) * 0.5;
        
        const deathPhase = this.dead ? 1 - (this.deathTimer / CONFIG.DEATH_ANIMATION_TIME) : 0;
        SpriteRenderer.drawRaptor(ctx, this.state, this.animFrame, this.facing, this.attackPhase, this.flashTimer, this.hasArmor, deathPhase);
        
        if (this.weapon && !this.dead) {
          const armX = this.facing === 1 ? 38 : 10;
          const armY = 22;
          
          ctx.save();
          if (this.facing === -1) {
            ctx.scale(-1, 1);
            ctx.translate(-48, 0);
          }
          
          if (this.weapon === 'boneclub') {
            const clubProgress = this.clubSwinging ? (1 - this.clubTimer / CONFIG.BONE_CLUB_RATE) : 0;
            const clubAngle = this.clubSwinging ? (-0.8 + clubProgress * 3) : -0.3;
            
            ctx.save();
            ctx.translate(armX + 8, armY);
            ctx.rotate(clubAngle);
            
            ctx.fillStyle = '#8a7a6a';
            ctx.fillRect(-2, 0, 4, 16);
            ctx.fillStyle = '#d0c8b8';
            ctx.beginPath();
            ctx.ellipse(0, -6, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#e8e0d0';
            ctx.beginPath();
            ctx.ellipse(-1, -8, 5, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#a09080';
            ctx.beginPath();
            ctx.arc(-5, -10, 2.5, 0, Math.PI * 2);
            ctx.arc(5, -10, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
          } else if (this.weapon === 'rapidfire') {
            ctx.save();
            ctx.translate(armX + 6, armY + 2);
            ctx.fillStyle = '#3a5a7a';
            ctx.fillRect(0, -2, 18, 5);
            ctx.fillStyle = '#5a7a9a';
            ctx.fillRect(2, -1, 14, 3);
            ctx.fillStyle = '#8abadf';
            ctx.fillRect(3, 0, 4, 1);
            ctx.fillStyle = '#2a3a4a';
            ctx.fillRect(16, -1, 4, 3);
            ctx.restore();
            
          } else if (this.weapon === 'acidgun') {
            ctx.save();
            ctx.translate(armX + 6, armY + 2);
            ctx.fillStyle = '#2a5a2a';
            ctx.fillRect(0, -3, 18, 6);
            ctx.fillStyle = '#4a8a4a';
            ctx.fillRect(2, -2, 14, 4);
            ctx.fillStyle = '#3a7a3a';
            ctx.beginPath();
            ctx.arc(8, -5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8afa8a';
            ctx.beginPath();
            ctx.arc(8, -5, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#4afa4a';
            ctx.fillRect(16, -1, 4, 3);
            ctx.fillRect(18, 2, 2, 2);
            ctx.restore();
          }
          
          ctx.restore();
        }
        
        ctx.restore();
      }

      getAttackHitbox() {
        const scale = CONFIG.PLAYER_SCALE;
        if (this.clubSwinging) {
          const offsetX = this.facing === 1 ? this.width * scale - 5 : -55;
          return { x: this.x + offsetX, y: this.y, width: 60, height: 60 };
        }
        const offsetX = this.facing === 1 ? this.width * scale - 5 : -35;
        return { x: this.x + offsetX, y: this.y + 5, width: 40, height: 50 };
      }
      
      getAttackDamage() {
        if (this.clubSwinging) return CONFIG.BONE_CLUB_DAMAGE;
        return CONFIG.PLAYER_DAMAGE;
      }
      
      isAttacking() { return this.attackTimer > 0.1 || this.clubSwinging; }
      
      getHitbox() { 
        const scale = CONFIG.PLAYER_SCALE;
        return { x: this.x + 10, y: this.y + 5, width: this.width * scale - 20, height: this.height * scale - 10 }; 
      }
    }

    // ============================================
    // ENEMY
    // ============================================
    class Enemy {
      constructor(x, y, difficultyMult = 1.0) {
        this.x = x; this.y = y;
        this.width = 50; this.height = 52;
        this.vx = 0; this.vy = 0;
        this.grounded = false; this.facing = -1;
        this.state = 'patrol';
        this.animFrame = 0; this.animTimer = 0;
        
        this.health = Math.floor(CONFIG.ENEMY_BASE_HEALTH * difficultyMult);
        this.maxHealth = this.health;
        this.damage = Math.floor(CONFIG.ENEMY_BASE_DAMAGE * difficultyMult);
        this.speed = CONFIG.ENEMY_BASE_SPEED * Math.min(1.5, difficultyMult);
        this.chaseSpeed = CONFIG.ENEMY_BASE_CHASE_SPEED * Math.min(1.5, difficultyMult);
        
        this.flashTimer = 0;
        this.attackTimer = 0; this.attackCooldown = 0;
        this.dead = false; this.deathTimer = 0;
        this.droppedLoot = false;
        this.patrolDir = Math.random() > 0.5 ? 1 : -1;
        this.patrolTimer = 2 + Math.random() * 2;
        this.sawPlayer = false;
        this.retreatTimer = 0;
      }

      takeDamage(amount) {
        if (this.dead) return;
        this.health -= amount;
        this.flashTimer = 0.25;
        if (this.health <= 0) { 
          this.health = 0; 
          this.dead = true; 
          this.state = 'dying';
          this.deathTimer = CONFIG.ENEMY_DEATH_TIME; 
        }
      }

      canSeePlayer(player) {
        const dx = player.x - this.x;
        if (Math.abs(dx) > CONFIG.ENEMY_SIGHT_RANGE) return false;
        return (dx > 0 && this.facing === 1) || (dx < 0 && this.facing === -1);
      }

      update(dt, player) {
        const C = CONFIG;
        if (this.flashTimer > 0) this.flashTimer -= dt;
        if (this.attackCooldown > 0) this.attackCooldown -= dt;
        if (this.retreatTimer > 0) this.retreatTimer -= dt;

        if (this.dead) {
          this.deathTimer -= dt;
          return { remove: this.deathTimer <= 0, dropLoot: !this.droppedLoot };
        }

        this.animTimer += dt;
        if (this.animTimer > 0.1) { this.animTimer = 0; this.animFrame = (this.animFrame + 1) % 4; }

        if (this.attackTimer > 0) { 
          this.attackTimer -= dt; 
          this.state = 'attack'; 
          if (this.attackTimer <= 0) {
            this.retreatTimer = 0.6;
          }
          return { remove: false }; 
        }

        const dx = player.x - this.x;
        const distance = Math.abs(dx);

        if (this.canSeePlayer(player) && !player.dead) this.sawPlayer = true;

        if (this.retreatTimer > 0) {
          this.state = 'retreat';
          const retreatDir = dx > 0 ? -1 : 1;
          this.facing = dx > 0 ? 1 : -1;
          this.vx = retreatDir * this.speed;
        }
        else if (this.sawPlayer && distance < CONFIG.ENEMY_SIGHT_RANGE * 1.5 && !player.dead) {
          this.state = 'chase';
          this.facing = dx > 0 ? 1 : -1;
          
          if (distance > C.ENEMY_ATTACK_RANGE + 10) {
            this.vx = this.facing * this.chaseSpeed;
          } else if (distance < C.ENEMY_RETREAT_DISTANCE) {
            this.vx = -this.facing * this.speed * 0.5;
          } else {
            this.vx = 0;
          }
          
          if (distance < C.ENEMY_ATTACK_RANGE && this.attackCooldown <= 0) {
            this.attackTimer = 0.4;
            this.attackCooldown = C.ENEMY_ATTACK_COOLDOWN;
            this.state = 'attack';
            this.vx = 0;
          }
        } else {
          this.state = 'patrol';
          this.sawPlayer = false;
          this.patrolTimer -= dt;
          if (this.patrolTimer <= 0) { this.patrolDir *= -1; this.patrolTimer = 2 + Math.random() * 2; }
          this.facing = this.patrolDir;
          this.vx = this.patrolDir * this.speed;
        }

        this.vy += C.GRAVITY * dt;
        this.vy = Math.min(this.vy, C.MAX_FALL_SPEED);
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        const groundY = C.CANVAS_HEIGHT - C.GROUND_HEIGHT;
        const scaledHeight = this.height * CONFIG.ENEMY_SCALE;
        if (this.y + scaledHeight > groundY) { 
          this.y = groundY - scaledHeight; 
          this.vy = 0; 
          this.grounded = true; 
        }
        if (this.x < 20) { this.x = 20; this.patrolDir = 1; }
        if (this.x + this.width > C.LEVEL_WIDTH - 20) { this.x = C.LEVEL_WIDTH - this.width - 20; this.patrolDir = -1; }

        return { remove: false };
      }

      draw(ctx, camera) {
        const sx = this.x - camera.x;
        const sy = this.y - camera.y;
        const scale = CONFIG.ENEMY_SCALE;
        
        if (sx < -80 || sx > CONFIG.CANVAS_WIDTH + 80) return;

        ctx.save();
        ctx.translate(sx, sy);
        ctx.scale(scale, scale);
        
        const deathPhase = this.dead ? 1 - (this.deathTimer / CONFIG.ENEMY_DEATH_TIME) : 0;
        
        if (this.dead) ctx.globalAlpha = 1 - (deathPhase * 0.7);
        else if (this.flashTimer > 0) ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.05) * 0.5;
        
        SpriteRenderer.drawBabySpino(ctx, this.state, this.animFrame, this.facing, this.flashTimer, deathPhase);
        ctx.restore();

        if (this.health < this.maxHealth && !this.dead) {
          const bw = 35, bh = 5;
          const bx = sx + (this.width * scale - bw) / 2;
          const by = sy - 12;
          ctx.fillStyle = '#222';
          ctx.fillRect(bx, by, bw, bh);
          const hp = this.health / this.maxHealth;
          ctx.fillStyle = hp > 0.5 ? '#4a4' : hp > 0.25 ? '#aa4' : '#a44';
          ctx.fillRect(bx + 1, by + 1, (bw - 2) * hp, bh - 2);
        }
      }

      getHitbox() { 
        const scale = CONFIG.ENEMY_SCALE;
        return { x: this.x, y: this.y, width: this.width * scale, height: this.height * scale }; 
      }
      getAttackHitbox() {
        const scale = CONFIG.ENEMY_SCALE;
        const ox = this.facing === 1 ? this.width * scale : -25;
        return { x: this.x + ox, y: this.y + 10 * scale, width: 30, height: 35 };
      }
      isAttacking() { return this.attackTimer > 0.2; }
    }

    // ============================================
    // GAME SYSTEMS
    // ============================================
    class SpawnManager {
      constructor() {
        this.spawnZones = [];
        this.enemies = [];
        this.pickups = [];
        this.bullets = [];
        for (let x = 400; x < CONFIG.LEVEL_WIDTH - 200; x += CONFIG.SPAWN_DISTANCE) {
          this.spawnZones.push({ x, triggered: false });
        }
        // Weapon spawns on ground
        const groundY = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT;
        this.pickups.push(new Pickup(250, groundY - 10, 'armor'));
        this.pickups.push(new Pickup(450, groundY - 10, 'rapidfire'));
        this.pickups.push(new Pickup(700, groundY - 10, 'boneclub'));
        this.pickups.push(new Pickup(950, groundY - 10, 'acidgun'));
        this.pickups.push(new Pickup(1200, groundY - 10, 'armor'));
        this.pickups.push(new Pickup(1500, groundY - 10, 'rapidfire'));
        this.pickups.push(new Pickup(1800, groundY - 10, 'boneclub'));
        this.pickups.push(new Pickup(2100, groundY - 10, 'acidgun'));
        this.pickups.push(new Pickup(2400, groundY - 10, 'armor'));
        this.pickups.push(new Pickup(2700, groundY - 10, 'rapidfire'));
        
        // NEW Phase 9 - Collectibles (rare spawns)
        this.pickups.push(new Pickup(600, groundY - 10, 'egg'));
        this.pickups.push(new Pickup(1400, groundY - 10, 'fossil'));
        this.pickups.push(new Pickup(2000, groundY - 10, 'crystal'));
        this.pickups.push(new Pickup(2800, groundY - 10, 'egg'));
        this.pickups.push(new Pickup(3500, groundY - 10, 'fossil'));
        this.pickups.push(new Pickup(4300, groundY - 10, 'crystal'));
        
        // Resources scattered around
        for (let i = 0; i < 15; i++) {
          const x = 400 + i * 320;
          this.pickups.push(new Pickup(x, groundY - 10, 'wood'));
        }
        for (let i = 0; i < 12; i++) {
          const x = 350 + i * 400;
          this.pickups.push(new Pickup(x, groundY - 10, 'stone'));
        }
        // Metal is rare
        this.pickups.push(new Pickup(1100, groundY - 10, 'metal'));
        this.pickups.push(new Pickup(2300, groundY - 10, 'metal'));
        this.pickups.push(new Pickup(3600, groundY - 10, 'metal'));
        this.pickups.push(new Pickup(4800, groundY - 10, 'metal'));
      }

      update(dt, player, particles) {
        const diffMult = GameStats.getDifficultyMultiplier(player.x);
        
        for (const zone of this.spawnZones) {
          if (!zone.triggered && Math.abs(player.x - zone.x) < 200) {
            if (this.enemies.length < CONFIG.MAX_ENEMIES) {
              const groundY = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT;
              const enemyHeight = 38 * CONFIG.ENEMY_SCALE;
              this.enemies.push(new Enemy(zone.x + (Math.random() - 0.5) * 100, groundY - enemyHeight, diffMult));
            }
            zone.triggered = true;
          }
        }

        for (let i = this.enemies.length - 1; i >= 0; i--) {
          const result = this.enemies[i].update(dt, player);
          if (result.dropLoot && this.enemies[i].dead && !this.enemies[i].droppedLoot) {
            const groundY = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT;
            // Drop meat AND bones
            this.pickups.push(new Pickup(this.enemies[i].x + 15, groundY - 10, 'meat'));
            this.pickups.push(new Pickup(this.enemies[i].x + 25, groundY - 10, 'bones'));
            this.enemies[i].droppedLoot = true;
            particles.createDeathCloud(this.enemies[i].x + 25, this.enemies[i].y + 20);
            GameStats.defeatEnemy();
          }
          if (result.remove) this.enemies.splice(i, 1);
        }

        for (let i = this.pickups.length - 1; i >= 0; i--) {
          if (this.pickups[i].update(dt)) this.pickups.splice(i, 1);
        }

        for (let i = this.bullets.length - 1; i >= 0; i--) {
          if (this.bullets[i].update(dt)) this.bullets.splice(i, 1);
        }

        for (const puddle of Background.puddles) {
          if (puddle.collected) {
            puddle.respawnTimer -= dt;
            if (puddle.respawnTimer <= 0) puddle.collected = false;
          }
        }

        // Update tree timers
        for (const tree of Background.trees) {
          if (tree.shakeTimer > 0) tree.shakeTimer -= dt;
          if (tree.hitCooldown > 0) tree.hitCooldown -= dt;
          if (tree.broken) {
            tree.respawnTimer -= dt;
            if (tree.respawnTimer <= 0) {
              tree.broken = false;
              tree.hp = tree.maxHp;
            }
          }
        }

        // Update rock timers
        for (const rock of Background.rocks) {
          if (rock.shakeTimer > 0) rock.shakeTimer -= dt;
          if (rock.hitCooldown > 0) rock.hitCooldown -= dt;
          if (rock.broken) {
            rock.respawnTimer -= dt;
            if (rock.respawnTimer <= 0) {
              rock.broken = false;
              rock.hp = rock.maxHp;
            }
          }
        }
      }

      draw(ctx, camera) {
        for (const enemy of this.enemies) enemy.draw(ctx, camera);
        for (const pickup of this.pickups) pickup.draw(ctx, camera);
        for (const bullet of this.bullets) bullet.draw(ctx, camera);
      }
    }

    const Combat = {
      checkCollision(a, b) {
        return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
      },
      update(player, spawnManager, particles) {
        const enemies = spawnManager.enemies;
        const pickups = spawnManager.pickups;
        const bullets = spawnManager.bullets;

        if (Input.keys.shoot && player.weapon && player.weapon !== 'boneclub') {
          player.shoot(bullets);
        }

        for (const bullet of bullets) {
          if (bullet.dead) continue;
          for (const enemy of enemies) {
            if (enemy.dead) continue;
            if (this.checkCollision(bullet.getHitbox(), enemy.getHitbox())) {
              enemy.takeDamage(bullet.damage);
              bullet.dead = true;
              particles.createHitSparks(bullet.x, bullet.y);
            }
          }
        }

        for (const enemy of enemies) {
          if (enemy.dead) continue;
          if (player.isAttacking() && this.checkCollision(player.getAttackHitbox(), enemy.getHitbox())) {
            enemy.takeDamage(player.getAttackDamage());
            particles.createHitSparks(enemy.x + 25, enemy.y + 20);
          }
          if (enemy.isAttacking() && this.checkCollision(enemy.getAttackHitbox(), player.getHitbox())) {
            player.takeDamage(enemy.damage);
          }
        }

        // Block breaking - trees
        if (player.isAttacking()) {
          const atkBox = player.getAttackHitbox();
          const groundY = CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT;
          for (const tree of Background.trees) {
            if (tree.broken) continue;
            // Tree hitbox uses world coordinates (not parallax-shifted screen coords)
            // Trees use 0.7 parallax, so world X = tree.x / 0.7
            const treeWorldX = tree.x / 0.7;
            const treeBox = { x: treeWorldX + tree.width * 0.3, y: groundY - tree.height, width: tree.width * 0.4, height: tree.height };
            if (this.checkCollision(atkBox, treeBox)) {
              if (!tree.hitCooldown || tree.hitCooldown <= 0) {
                tree.hp--;
                tree.shakeTimer = 0.3;
                tree.hitCooldown = 0.4;
                particles.createWoodChips(treeWorldX + tree.width * 0.5, groundY - tree.height * 0.4);
                if (tree.hp <= 0) {
                  tree.broken = true;
                  tree.respawnTimer = 45;
                  particles.createBreakEffect(treeWorldX + tree.width * 0.5, groundY - tree.height * 0.3, 'rgba(140, 100, 60, 1)');
                  // Drop wood pickup
                  const pickup = new Pickup(treeWorldX + tree.width * 0.5 - 12, groundY - 10, 'wood');
                  pickups.push(pickup);
                }
              }
              break;
            }
          }
          // Block breaking - rocks
          for (const rock of Background.rocks) {
            if (rock.broken) continue;
            // Rocks use 0.9 parallax
            const rockWorldX = rock.x / 0.9;
            const rockBox = { x: rockWorldX - rock.size, y: groundY - rock.size, width: rock.size * 2, height: rock.size };
            if (this.checkCollision(atkBox, rockBox)) {
              if (!rock.hitCooldown || rock.hitCooldown <= 0) {
                rock.hp--;
                rock.shakeTimer = 0.3;
                rock.hitCooldown = 0.4;
                particles.createStoneChips(rockWorldX, groundY - rock.size * 0.3);
                if (rock.hp <= 0) {
                  rock.broken = true;
                  rock.respawnTimer = 60;
                  particles.createBreakEffect(rockWorldX, groundY - rock.size * 0.3, 'rgba(160, 160, 160, 1)');
                  // Drop stone pickup
                  const pickup = new Pickup(rockWorldX - 12, groundY - 10, 'stone');
                  pickups.push(pickup);
                  // Chance to drop metal
                  if (Math.random() < 0.2) {
                    const metalPickup = new Pickup(rockWorldX + 12, groundY - 10, 'metal');
                    pickups.push(metalPickup);
                  }
                }
              }
              break;
            }
          }
        }

        const playerBox = player.getHitbox();
        for (let i = pickups.length - 1; i >= 0; i--) {
          const p = pickups[i];
          if (this.checkCollision(playerBox, p.getHitbox())) {
            // NEW Phase 9 - Items go to inventory, not auto-consumed
            if (p.type === 'meat' || p.type === 'berries') {
              Inventory.add(p.type, 1);
              p.collected = true;
            } else if (p.type === 'wood' || p.type === 'stone' || p.type === 'bones' || p.type === 'metal') {
              Inventory.add(p.type, p.type === 'wood' ? CONFIG.WOOD_PER_TREE : 
                                    p.type === 'stone' ? CONFIG.STONE_PER_ROCK :
                                    p.type === 'bones' ? CONFIG.BONES_PER_ENEMY : 1);
              p.collected = true;
            } else if (p.type === 'egg' || p.type === 'fossil' || p.type === 'crystal') {
              Inventory.add(p.type === 'egg' ? 'eggs' : 
                           p.type === 'fossil' ? 'fossils' : 'crystals', 1);
              p.collected = true;
            } else if (p.type === 'rapidfire') {
              // Weapons still work the old way (can't craft in inventory)
              if (!player.weapon || player.weapon === 'rapidfire') {
                player.weapon = 'rapidfire';
                player.weaponAmmo += 40;
                p.collected = true;
              }
            } else if (p.type === 'acidgun') {
              if (!player.weapon || player.weapon === 'acidgun') {
                player.weapon = 'acidgun';
                player.weaponAmmo += 20;
                p.collected = true;
              }
            } else if (p.type === 'boneclub') {
              if (!player.weapon || player.weapon === 'boneclub') {
                player.weapon = 'boneclub';
                player.weaponAmmo += 15;
                p.collected = true;
              }
            } else if (p.type === 'armor') {
              if (!player.hasArmor) {
                player.hasArmor = true;
                player.armorHits = 0;
                p.collected = true;
              }
            }
          }
        }

        // Berries go to inventory now
        for (const bush of Background.bushes) {
          if (bush.collected) continue;
          if (Math.abs(player.x + player.width / 2 - bush.x) < 20 && player.y > CONFIG.CANVAS_HEIGHT - CONFIG.GROUND_HEIGHT - 60) {
            Inventory.add('berries', 1);
            bush.collected = true;
          }
        }

        for (const puddle of Background.puddles) {
          if (puddle.collected) continue;
          if (Math.abs(player.x + player.width / 2 - puddle.x) < 18) {
            player.restoreThirst(CONFIG.PUDDLE_RESTORE);
            puddle.collected = true;
            puddle.respawnTimer = 25;
          }
        }

        for (const pond of Background.ponds) {
          const px = player.x + player.width / 2;
          const pondWidth = Math.max(...pond.points.map(p => Math.abs(p.x))) * 2;
          if (px > pond.x - pondWidth / 2 && px < pond.x + pondWidth / 2) {
            player.restoreThirst(CONFIG.POND_RESTORE_RATE * (1/60));
          }
        }
      }
    };

    // ============================================
    // UI
    // ============================================
    const UI = {
      draw(ctx, player, width) {
        const bw = 100, bh = 14, gap = 6, sx = 8, sy = 6;

        this.drawBar(ctx, sx, sy, bw, bh, player.health, player.maxHealth, '#5a5', '#833', 'HP', player.health < 30);
        this.drawBar(ctx, sx + bw + gap, sy, bw, bh, player.hunger, CONFIG.MAX_HUNGER, '#a84', '#543', 'FOOD', player.hunger < 20);
        this.drawBar(ctx, sx + (bw + gap) * 2, sy, bw, bh, player.thirst, CONFIG.MAX_THIRST, '#48a', '#345', 'H2O', player.thirst < 20);

        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(width - 95, sy, 87, 28);
        ctx.fillStyle = '#ffd700';
        ctx.font = '7px "Press Start 2P", monospace';
        ctx.fillText('SCORE', width - 92, sy + 9);
        ctx.fillStyle = '#fff';
        ctx.fillText(GameStats.currentScore.toString(), width - 92, sy + 19);
        ctx.fillStyle = '#aaa';
        ctx.font = '6px "Press Start 2P", monospace';
        ctx.fillText(`HI: ${GameStats.highScore}`, width - 92, sy + 26);

        if (player.weapon) {
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(width - 75, sy + 32, 67, 22);
          ctx.fillStyle = '#fff';
          ctx.font = '7px "Press Start 2P", monospace';
          const weaponNames = { rapidfire: 'RAPID', acidgun: 'ACID', boneclub: 'CLUB' };
          ctx.fillText(weaponNames[player.weapon] || player.weapon, width - 72, sy + 42);
          ctx.fillStyle = '#aaa';
          ctx.fillText(`x${player.weaponAmmo}`, width - 72, sy + 51);
        }

        if (player.hasArmor) {
          ctx.fillStyle = '#8090a0';
          ctx.fillRect(sx, sy + bh + 4, 40, 12);
          ctx.fillStyle = '#fff';
          ctx.font = '6px "Press Start 2P", monospace';
          ctx.fillText('ARMOR', sx + 3, sy + bh + 12);
        }
        
        // NEW Phase 9 - Inventory Display
        const invX = 8, invY = 200;
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(invX, invY, 250, 65);
        ctx.strokeStyle = '#4a6a4a';
        ctx.lineWidth = 2;
        ctx.strokeRect(invX, invY, 250, 65);

        // Header
        ctx.fillStyle = '#6c6';
        ctx.font = '8px "Press Start 2P", monospace';
        ctx.fillText('INVENTORY', invX + 5, invY + 12);
        ctx.fillStyle = '#aaa';
        ctx.font = '6px "Press Start 2P", monospace';
        ctx.fillText('[E] Eat  [C] Craft', invX + 110, invY + 12);

        // Food section
        ctx.fillStyle = '#8f8';
        ctx.font = '7px "Press Start 2P", monospace';
        let foodY = invY + 26;
        ctx.fillText('Food:', invX + 5, foodY);
        ctx.fillStyle = '#fff';
        let foodText = '';
        if (Inventory.items.berries > 0) foodText += `Berries:${Inventory.items.berries} `;
        if (Inventory.items.meat > 0) foodText += `Meat:${Inventory.items.meat}`;
        if (foodText === '') foodText = 'None';
        ctx.fillText(foodText, invX + 50, foodY);

        // Resources section
        ctx.fillStyle = '#da6';
        let resY = invY + 40;
        ctx.fillText('Res:', invX + 5, resY);
        ctx.fillStyle = '#fff';
        let resText = '';
        if (Inventory.items.wood > 0) resText += `Wood:${Inventory.items.wood} `;
        if (Inventory.items.stone > 0) resText += `Stone:${Inventory.items.stone} `;
        if (Inventory.items.bones > 0) resText += `Bones:${Inventory.items.bones} `;
        if (Inventory.items.metal > 0) resText += `Metal:${Inventory.items.metal}`;
        if (resText === '') resText = 'None';
        ctx.fillText(resText, invX + 50, resY);

        // Collectibles section
        const totalCollectibles = Inventory.collectibles.eggs + Inventory.collectibles.fossils + Inventory.collectibles.crystals;
        ctx.fillStyle = '#b6f';
        let colY = invY + 54;
        ctx.fillText('Rare:', invX + 5, colY);
        ctx.fillStyle = '#fff';
        let colText = '';
        if (Inventory.collectibles.eggs > 0) colText += `Eggs:${Inventory.collectibles.eggs} `;
        if (Inventory.collectibles.fossils > 0) colText += `Fossils:${Inventory.collectibles.fossils} `;
        if (Inventory.collectibles.crystals > 0) colText += `Crystals:${Inventory.collectibles.crystals}`;
        if (colText === '') colText = 'None';
        ctx.fillText(colText, invX + 50, colY);
      },

      drawBar(ctx, x, y, w, h, value, max, colorHigh, colorLow, label, warning = false) {
        const pct = Math.max(0, value / max);
        // Warning flash
        if (warning && Math.sin(Date.now() / 150) > 0) {
          ctx.fillStyle = 'rgba(255,0,0,0.35)';
          ctx.fillRect(x - 2, y - 2, w + 4, h + 4);
        }
        // Background
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(x, y, w, h);
        // Fill gradient
        const grad = ctx.createLinearGradient(x, y, x, y + h);
        grad.addColorStop(0, pct > 0.3 ? colorHigh : colorLow);
        grad.addColorStop(0.5, pct > 0.3 ? colorHigh : colorLow);
        grad.addColorStop(1, pct > 0.3 ? '#333' : '#300');
        ctx.fillStyle = grad;
        ctx.fillRect(x + 1, y + 1, (w - 2) * pct, h - 2);
        // Shine highlight
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(x + 1, y + 1, (w - 2) * pct, h / 3);
        // Border
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, w, h);
        // Label text
        ctx.fillStyle = '#fff';
        ctx.font = '7px "Press Start 2P", monospace';
        ctx.fillText(label, x + 3, y + h - 3);
        // Value text
        const valText = Math.floor(value).toString();
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.font = '6px "Press Start 2P", monospace';
        ctx.fillText(valText, x + w - valText.length * 7 - 3, y + h - 4);
      },

      drawGameOver(ctx, width, height) {
        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = '#f44';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', width / 2, height / 2 - 35);
        
        ctx.fillStyle = '#ffd700';
        ctx.font = '10px "Press Start 2P", monospace';
        ctx.fillText(`SCORE: ${GameStats.currentScore}`, width / 2, height / 2 - 10);
        
        if (GameStats.currentScore >= GameStats.highScore) {
          ctx.fillStyle = '#4f4';
          ctx.font = '8px "Press Start 2P", monospace';
          ctx.fillText('NEW HIGH SCORE!', width / 2, height / 2 + 5);
        } else {
          ctx.fillStyle = '#aaa';
          ctx.font = '8px "Press Start 2P", monospace';
          ctx.fillText(`HIGH: ${GameStats.highScore}`, width / 2, height / 2 + 5);
        }
        
        ctx.fillStyle = '#fff';
        ctx.font = '7px "Press Start 2P", monospace';
        ctx.fillText(`Distance: ${GameStats.distance}m`, width / 2, height / 2 + 20);
        ctx.fillText(`Enemies: ${GameStats.enemiesDefeated}`, width / 2, height / 2 + 32);
        
        ctx.font = '8px "Press Start 2P", monospace';
        ctx.fillText('Press Z or tap ATTACK to restart', width / 2, height / 2 + 50);
        ctx.textAlign = 'left';
      }
    };

    class Camera {
      constructor() { this.x = 0; this.y = 0; }
      follow(player, w, h, levelW) {
        let tx = player.x + player.width / 2 - w / 2;
        tx = Math.max(0, Math.min(tx, levelW - w));
        this.x += (tx - this.x) * CONFIG.CAMERA_LERP;
      }
    }

    class Game {
      constructor() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = CONFIG.CANVAS_WIDTH;
        this.canvas.height = CONFIG.CANVAS_HEIGHT;
        this.ctx.imageSmoothingEnabled = false;
        this.gameState = 'playing';
        Background.init();
        GameStats.init();
        GameStats.reset();
        DayNight.time = 0.35; // Start at day
        Birds.init(); // Initialize birds
        this.player = new Player(100, 100);
        this.camera = new Camera();
        this.spawnManager = new SpawnManager();
        this.particles = new ParticleSystem();
        this.lastTime = performance.now();
        Input.init();
        this.loop();
      }

      restart() {
        Background.bushes.forEach(b => b.collected = false);
        Background.puddles.forEach(p => { p.collected = false; p.respawnTimer = 0; });
        Background.trees.forEach(t => { t.broken = false; t.hp = t.maxHp; t.shakeTimer = 0; t.hitCooldown = 0; t.respawnTimer = 0; });
        Background.rocks.forEach(r => { r.broken = false; r.hp = r.maxHp; r.shakeTimer = 0; r.hitCooldown = 0; r.respawnTimer = 0; });
        GameStats.reset();
        Inventory.reset(); // NEW Phase 9 - Reset inventory
        CraftingUI.isOpen = false; // Close crafting menu
        DayNight.time = 0.35;
        Birds.init(); // Reset birds
        this.player = new Player(100, 100);
        this.camera = new Camera();
        this.spawnManager = new SpawnManager();
        this.particles = new ParticleSystem();
        this.gameState = 'playing';
      }

      loop() {
        const now = performance.now();
        const dt = Math.min((now - this.lastTime) / 1000, 0.05);
        this.lastTime = now;
        this.update(dt);
        this.render();
        requestAnimationFrame(() => this.loop());
      }

      update(dt) {
        if (this.gameState === 'gameover') {
          if (Input.isAttackJustPressed() || Input.keys.jump) this.restart();
          return;
        }
        
        // NEW Phase 9 - Crafting menu toggle
        if (Input.isCraftJustPressed()) {
          CraftingUI.toggle();
        }
        
        // NEW Phase 9 - Eating from inventory
        if (Input.isEatJustPressed() && !CraftingUI.isOpen) {
          if (Inventory.has('berries', 1)) {
            Inventory.remove('berries', 1);
            this.player.restoreHunger(CONFIG.BERRY_RESTORE);
          } else if (Inventory.has('meat', 1)) {
            Inventory.remove('meat', 1);
            this.player.restoreHunger(CONFIG.MEAT_RESTORE);
          }
        }
        
        // Crafting menu navigation and crafting
        if (CraftingUI.isOpen) {
          if (Input.isUpJustPressed()) {
            CraftingUI.moveSelectionUp();
          }
          if (Input.isDownJustPressed()) {
            CraftingUI.moveSelectionDown();
          }
          if (Input.isAttackJustPressed()) {
            // Craft the selected recipe
            const recipes = ['boneclub', 'rapidfire', 'acidgun', 'healthpotion', 'armor'];
            const selectedKey = recipes[CraftingUI.selectedRecipe];
            if (CraftingUI.canCraft(selectedKey)) {
              CraftingUI.craft(selectedKey, this.player);
            }
          }
        }
        
        DayNight.update(dt);
        Birds.update(dt); // Update birds
        this.player.update(dt);
        GameStats.updateDistance(this.player.x);
        this.spawnManager.update(dt, this.player, this.particles);
        Combat.update(this.player, this.spawnManager, this.particles);
        this.particles.update(dt);
        this.camera.follow(this.player, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT, CONFIG.LEVEL_WIDTH);
        if (this.player.dead && this.player.deathTimer <= 0) {
          GameStats.saveHighScore();
          this.gameState = 'gameover';
        }
      }

      render() {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;
        ctx.clearRect(0, 0, w, h);
        Background.draw(ctx, this.camera, w, h);
        this.spawnManager.draw(ctx, this.camera);
        this.particles.draw(ctx, this.camera);
        this.player.draw(ctx, this.camera);

        // Day/night ambient overlay
        const brightness = DayNight.getBrightness();
        if (brightness < 1.0) {
          ctx.fillStyle = `rgba(10, 10, 30, ${(1 - brightness) * 0.5})`;
          ctx.fillRect(0, 0, w, h);
        }

        // Subtle vignette
        const vigGrad = ctx.createRadialGradient(w / 2, h / 2, h * 0.4, w / 2, h / 2, h * 0.9);
        vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
        vigGrad.addColorStop(1, 'rgba(0,0,0,0.3)');
        ctx.fillStyle = vigGrad;
        ctx.fillRect(0, 0, w, h);

        UI.draw(ctx, this.player, w);
        CraftingUI.draw(ctx, w, h);
        if (this.gameState === 'gameover') UI.drawGameOver(ctx, w, h);
      }
    }

    window.addEventListener('load', () => new Game());
  </script>
</body>
</html>
